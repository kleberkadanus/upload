
const qrcodeTerminal = require("qrcode-terminal");
const qrcode = require("qrcode");
const fs = require("fs");
const { Client, LocalAuth, MessageMedia, List, Buttons } = require("whatsapp-web.js");
const mariadb = require("mariadb");
const { google } = require("googleapis");
const path = require("path");
const { Client: GoogleMapsClient } = require("@googlemaps/google-maps-services-js");

// --- Database Configuration ---
const pool = mariadb.createPool({
  host: "104.234.30.102",
  user: "root",
  password: "+0q)3E3.G]Yu",
  database: "WTS2",
  connectionLimit: 5,
  connectTimeout: 15000,
  acquireTimeout: 15000,
});

// --- Google Calendar Configuration ---
const CALENDAR_SCOPES = ["https://www.googleapis.com/auth/calendar"];
const SERVICE_ACCOUNT_KEY_PATH = path.join(__dirname, "service_account.json");
const CALENDAR_ID = "kleberkadanus94@gmail.com"; // Agenda principal do usu√°rio

const googleAuth = new google.auth.GoogleAuth({
  keyFile: SERVICE_ACCOUNT_KEY_PATH,
  scopes: CALENDAR_SCOPES,
});

const calendar = google.calendar({ version: "v3", auth: googleAuth });

// --- WhatsApp Client Setup ---
const client = new Client({
  authStrategy: new LocalAuth(),
  puppeteer: {
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  },
});

// Store conversation state for each user { senderId: { state: ..., data: {} } }
const userState = {};
const QR_FILE_PATH = "/home/ubuntu/whatsapp_bot_project/qrcode.png";

client.on("qr", (qr) => {
  console.log("[EVENTO QR] QR Code recebido. Tentando salvar como imagem...");
  qrcode.toFile(QR_FILE_PATH, qr, { errorCorrectionLevel: "H" }, function (err) {
    if (err) {
      console.error("[ERRO QR] Erro ao salvar QR code como imagem:", err);
      console.log(
        "[QR ALTERNATIVO] Exibindo QR code no terminal (pode ser grande):"
      );
      qrcodeTerminal.generate(qr, { small: true });
    } else {
      console.log(`[QR SALVO] QR Code salvo como imagem em: ${QR_FILE_PATH}`);
      console.log(
        "[A√á√ÉO NECESS√ÅRIA] Pe√ßa ao seu assistente (Manus) para enviar o arquivo qrcode.png para voc√™."
      );
    }
  });
});

client.on("ready", () => {
  console.log("[EVENTO READY] Cliente WhatsApp est√° pronto!");
  if (fs.existsSync(QR_FILE_PATH)) {
    try {
      fs.unlinkSync(QR_FILE_PATH);
      console.log(`[INFO] Arquivo QR code (${QR_FILE_PATH}) removido ap√≥s conex√£o.`);
    } catch (unlinkErr) {
      console.error(`[ERRO] Falha ao remover arquivo QR code: ${unlinkErr.message}`);
    }
  }
});

client.on("auth_failure", (msg) => {
  console.error("[EVENTO AUTH_FAILURE] Falha na autentica√ß√£o:", msg);
});

client.on("disconnected", (reason) => {
  console.log("[EVENTO DISCONNECTED] Cliente foi desconectado:", reason);
});

// --- Message Handling Logic ---
client.on("message", async (msg) => {
  const chat = await msg.getChat();
  const contact = await msg.getContact();
  const senderNumber = contact.id.user;
  const senderId = contact.id._serialized;

  console.log(
    `[MSG RECEBIDA] De: ${senderNumber} (${contact.pushname || "N/A"}) | Chat: ${chat.id.user} | Tipo: ${msg.type} | Corpo: ${msg.body}`
  );

  if (chat.isGroup || msg.isStatus) {
    console.log("[INFO] Ignorando msg de grupo/status.");
    return;
  }

  // Verificar se √© um comando de atendente ou t√©cnico
  if (msg.body.startsWith("/")) {
    const commandParts = msg.body.split(" ");
    const command = commandParts[0].toLowerCase();
    const params = commandParts.slice(1).join(" ");

    let conn;
    try {
      conn = await pool.getConnection();
      const isAttendant = await conn.query(
        "SELECT id, name FROM attendants WHERE whatsapp_number = ?",
        [senderNumber]
      );

      if (isAttendant.length > 0) {
        const attendantId = isAttendant[0].id;
        const attendantName = isAttendant[0].name;
        await conn.query(
          "UPDATE attendants SET status = 'available', last_activity = NOW() WHERE id = ?",
          [attendantId]
        );
        // Processar comandos de atendente (c√≥digo existente omitido para brevidade)
        switch (command) {
            case '/finalizar':
                const activeTickets = await conn.query(
                    "SELECT sq.id, sq.whatsapp_number, c.name, c.id as client_id FROM support_queue sq JOIN clients c ON sq.client_id = c.id WHERE sq.assigned_to = ? AND sq.status = 'in_progress'",
                    [attendantId]
                );
                if (activeTickets.length === 0) {
                    await client.sendMessage(senderId, "Voc√™ n√£o possui nenhum atendimento em andamento para finalizar.");
                    break;
                }
                for (const ticket of activeTickets) {
                    await conn.query("UPDATE support_queue SET status = 'completed' WHERE id = ?", [ticket.id]);
                    const clientId = `${ticket.whatsapp_number}@c.us`;
                    await client.sendMessage(clientId, `Seu atendimento com ${attendantName} foi finalizado. Agradecemos o contato!\n\nComo voc√™ avalia o atendimento recebido? (Digite um n√∫mero de 1 a 5 estrelas)`);
                    userState[clientId] = { state: "awaiting_rating", data: { clientId: ticket.client_id, reviewType: "attendant_support", attendantId: attendantId } };
                }
                const waitingClients = await conn.query(
                    "SELECT sq.id, sq.whatsapp_number, c.id as client_id, c.name FROM support_queue sq JOIN clients c ON sq.client_id = c.id WHERE sq.status = 'waiting' ORDER BY sq.created_at ASC LIMIT 1"
                );
                if (waitingClients.length > 0) {
                    const nextClient = waitingClients[0];
                    await conn.query("UPDATE support_queue SET status = 'in_progress', assigned_to = ? WHERE id = ?", [attendantId, nextClient.id]);
                    const clientInfo = `Nome: ${nextClient.name}\nTelefone: ${nextClient.whatsapp_number}`;
                    await client.sendMessage(senderId, `‚úÖ Atendimento(s) anterior(es) finalizado(s).\n\nüîî *Pr√≥ximo Cliente na Fila*\n\n${clientInfo}\n\nPara iniciar a conversa, use o comando:\n/falarcom ${nextClient.whatsapp_number}`);
                    const nextClientId = `${nextClient.whatsapp_number}@c.us`;
                    await client.sendMessage(nextClientId, `Ol√°! O atendente ${attendantName} est√° dispon√≠vel e ir√° atend√™-lo em instantes.`);
                } else {
                    await client.sendMessage(senderId, "‚úÖ Atendimento(s) finalizado(s). N√£o h√° mais clientes na fila de espera.");
                    await conn.query("UPDATE attendants SET status = 'available' WHERE id = ?", [attendantId]);
                }
                break;
            case '/falarcom':
                if (!params) {
                    await client.sendMessage(senderId, "Por favor, forne√ßa o n√∫mero do cliente. Exemplo: /falarcom 5541999999999");
                    break;
                }
                const clientNumber = params.trim();
                const clientIdToTalk = `${clientNumber}@c.us`;
                const clientExists = await conn.query("SELECT id, name FROM clients WHERE whatsapp_number = ?", [clientNumber]);
                if (clientExists.length === 0) {
                    await client.sendMessage(senderId, `Cliente com n√∫mero ${clientNumber} n√£o encontrado no sistema.`);
                    break;
                }
                const existingTicket = await conn.query("SELECT id, assigned_to FROM support_queue WHERE whatsapp_number = ? AND status = 'in_progress'", [clientNumber]);
                if (existingTicket.length > 0 && existingTicket[0].assigned_to !== attendantId) {
                    const otherAttendant = await conn.query("SELECT name FROM attendants WHERE id = ?", [existingTicket[0].assigned_to]);
                    const otherAttendantName = otherAttendant.length > 0 ? otherAttendant[0].name : "outro atendente";
                    await client.sendMessage(senderId, `Este cliente j√° est√° sendo atendido por ${otherAttendantName}.`);
                    break;
                }
                if (existingTicket.length > 0) {
                    await client.sendMessage(senderId, `Voc√™ j√° est√° em atendimento com ${clientExists[0].name}. Continue a conversa normalmente.`);
                } else {
                    const waitingTicket = await conn.query("SELECT id FROM support_queue WHERE whatsapp_number = ? AND status = 'waiting'", [clientNumber]);
                    if (waitingTicket.length > 0) {
                        await conn.query("UPDATE support_queue SET status = 'in_progress', assigned_to = ? WHERE id = ?", [attendantId, waitingTicket[0].id]);
                    } else {
                        await conn.query("INSERT INTO support_queue (client_id, whatsapp_number, status, assigned_to) VALUES (?, ?, 'in_progress', ?)", [clientExists[0].id, clientNumber, attendantId]);
                    }
                    await conn.query("UPDATE attendants SET status = 'busy' WHERE id = ?", [attendantId]);
                    await client.sendMessage(clientIdToTalk, `Ol√°! Sou ${attendantName}, atendente da empresa, e estou aqui para ajud√°-lo. Como posso ser √∫til hoje?`);
                    await client.sendMessage(senderId, `‚úÖ Atendimento iniciado com ${clientExists[0].name} (${clientNumber}).\nTodas as suas mensagens ser√£o encaminhadas para o cliente at√© que voc√™ use o comando /finalizar.`);
                }
                break;
            case '/enviarpix':
                 if (!params) {
                    await client.sendMessage(senderId, "Por favor, forne√ßa o n√∫mero do cliente. Exemplo: /enviarpix 5541999999999");
                    break;
                }
                const pixClientNumber = params.trim();
                const pixClientId = `${pixClientNumber}@c.us`;
                const pixConfig = await conn.query("SELECT value FROM config WHERE name = 'pix_key'");
                if (pixConfig.length === 0 || !pixConfig[0].value) {
                    await client.sendMessage(senderId, "Chave PIX n√£o configurada no sistema.");
                    break;
                }
                const pixKey = pixConfig[0].value;
                await client.sendMessage(pixClientId, `*Chave PIX para Pagamento*\n\nSegue nossa chave PIX para pagamento:\n\n${pixKey}\n\nAp√≥s realizar o pagamento, por favor envie o comprovante para confirmarmos.`);
                await client.sendMessage(senderId, `‚úÖ Chave PIX enviada com sucesso para o cliente ${pixClientNumber}.`);
                break;
            case '/enviarboleto':
                if (!params) {
                    await client.sendMessage(senderId, "Por favor, forne√ßa o n√∫mero do cliente. Exemplo: /enviarboleto 5541999999999");
                    break;
                }
                const boletoClientNumber = params.trim();
                const boletoClientId = `${boletoClientNumber}@c.us`;
                const boletoClient = await conn.query("SELECT id, name FROM clients WHERE whatsapp_number = ?", [boletoClientNumber]);
                if (boletoClient.length === 0) {
                    await client.sendMessage(senderId, `Cliente com n√∫mero ${boletoClientNumber} n√£o encontrado no sistema.`);
                    break;
                }
                const boletos = await conn.query("SELECT id, reference, due_date, amount, pdf_url FROM boletos WHERE client_id = ? ORDER BY due_date DESC", [boletoClient[0].id]);
                if (boletos.length === 0) {
                    await client.sendMessage(senderId, `N√£o foram encontrados boletos para o cliente ${boletoClient[0].name}.`);
                    break;
                }
                const latestBoleto = boletos[0];
                const dueDate = new Date(latestBoleto.due_date).toLocaleDateString('pt-BR');
                await client.sendMessage(boletoClientId, `*Segunda via de boleto*\n\nSegue a segunda via do seu boleto:\n\nRefer√™ncia: ${latestBoleto.reference}\nVencimento: ${dueDate}\nValor: R$ ${latestBoleto.amount.toFixed(2)}\n\nO boleto ser√° enviado em seguida.`);
                if (latestBoleto.pdf_url) {
                    try {
                        const media = await MessageMedia.fromUrl(latestBoleto.pdf_url);
                        await client.sendMessage(boletoClientId, media, { caption: `Boleto - Vencimento: ${dueDate}` });
                        await client.sendMessage(senderId, `‚úÖ Boleto enviado com sucesso para o cliente ${boletoClient[0].name}.`);
                    } catch (error) {
                        console.error("[ERRO] Falha ao enviar PDF do boleto:", error);
                        await client.sendMessage(senderId, `‚ùå Erro ao enviar PDF do boleto. URL inv√°lida ou inacess√≠vel: ${latestBoleto.pdf_url}`);
                    }
                } else {
                    await client.sendMessage(senderId, `‚ö†Ô∏è O boleto n√£o possui URL do PDF cadastrada no sistema.`);
                }
                break;
            default:
                await client.sendMessage(senderId, "Comando de atendente n√£o reconhecido. Use /finalizar, /falarcom [numero], /enviarpix [numero] ou /enviarboleto [numero].");
        }
        return; // Sai do fluxo normal, pois √© um comando de atendente
      }

      // Se n√£o for atendente, verificar se √© t√©cnico
      const technicianModule = require("./technician_module.js");
      const isTechnicianCommand = await technicianModule.processTechnicianCommand(client, conn, senderId, senderNumber, command, params);
      if (isTechnicianCommand) {
        return; // Sai do fluxo normal, pois √© um comando de t√©cnico
      }
    } catch (error) {
      console.error("[ERRO DB] Erro ao processar comando de atendente/t√©cnico:", error);
      await client.sendMessage(senderId, "Ocorreu um erro ao processar seu comando. Tente novamente mais tarde.");
    } finally {
      if (conn) conn.release();
    }
  }

  // Processar bot√µes de t√©cnico
  if (msg.selectedButtonId) {
    let conn;
    try {
      conn = await pool.getConnection();
      const technicianModule = require("./technician_module.js");
      const isTechnicianButton = await technicianModule.processTechnicianButton(client, conn, senderId, senderNumber, msg, userState);
      if (isTechnicianButton) {
        return; // Sai do fluxo normal, pois √© um bot√£o de t√©cnico
      }
    } catch (error) {
      console.error("[ERRO DB] Erro ao processar bot√£o de t√©cnico:", error);
      await client.sendMessage(senderId, "Ocorreu um erro ao processar sua a√ß√£o. Tente novamente mais tarde.");
    } finally {
      if (conn) conn.release();
    }
  }

  // Processar estados de t√©cnico
  const technicianStateInfo = userState[senderId];
  if (technicianStateInfo && technicianStateInfo.state && 
      (technicianStateInfo.state.startsWith('awaiting_technician') || 
       technicianStateInfo.state === 'awaiting_service_description' || 
       technicianStateInfo.state === 'awaiting_rejection_reason')) {
    let conn;
    try {
      conn = await pool.getConnection();
      const technicianModule = require("./technician_module.js");
      const isTechnicianState = await technicianModule.processTechnicianState(client, conn, senderId, senderNumber, msg, technicianStateInfo);
      if (isTechnicianState) {
        return; // Sai do fluxo normal, pois √© um estado de t√©cnico
      }
    } catch (error) {
      console.error("[ERRO DB] Erro ao processar estado de t√©cnico:", error);
      await client.sendMessage(senderId, "Ocorreu um erro ao processar sua solicita√ß√£o. Tente novamente mais tarde.");
    } finally {
      if (conn) conn.release();
    }
  }
  
  // --- L√≥gica de Cliente Normal ---
  let conn;
  let currentClient = null;
  try {
    conn = await pool.getConnection();
    const clientResult = await conn.query(
      "SELECT id, name, address, last_interaction_type FROM clients WHERE whatsapp_number = ? LIMIT 1",
      [senderNumber]
    );
    if (clientResult.length > 0) {
      currentClient = clientResult[0];
      console.log(`[DB] Cliente encontrado: ${currentClient.name}`);
    } else {
      console.log("[DB] Cliente n√£o encontrado, iniciando cadastro.");
    }
  } catch (dbError) {
    console.error("[ERRO DB] Falha ao buscar cliente:", dbError);
    await client.sendMessage(
      senderId,
      "Desculpe, estou com problemas para acessar nosso sistema no momento. Por favor, tente novamente em alguns instantes."
    );
    if (conn) conn.release();
    return;
  }

  const stateInfo = userState[senderId];

  if (!stateInfo) {
    if (!currentClient) {
      userState[senderId] = { state: "awaiting_name", data: {} };
      console.log(`[ESTADO] Novo estado: awaiting_name para ${senderId}`);
      await client.sendMessage(
        senderId,
        "Ol√°! Sou o assistente virtual da Kadan Tech. Para come√ßarmos, qual √© o seu nome?"
      );
    } else {
      // Cliente j√° cadastrado
      const buttons = new Buttons(
        `Ol√° ${currentClient.name}, bem-vindo(a) de volta! Seus dados cadastrados s√£o:\nEndere√ßo: ${currentClient.address || 'N√£o informado'}\n\nO que voc√™ gostaria de fazer?`,
        [
          { id: "main_menu", body: "Ver Menu Principal" },
          { id: "update_data", body: "Atualizar Meus Dados" },
        ],
        "Bem-vindo(a) de Volta!"
      );
      await client.sendMessage(senderId, buttons);
      userState[senderId] = { state: "awaiting_welcome_choice", data: { clientId: currentClient.id, name: currentClient.name, address: currentClient.address } };
      console.log(`[ESTADO] Novo estado: awaiting_welcome_choice para ${senderId}`);
    }
  } else {
    // Processar estado atual do cliente
    console.log(`[ESTADO] Processando estado ${stateInfo.state} para ${senderId}`);

    switch (stateInfo.state) {
      case "awaiting_name":
        const name = msg.body.trim();
        if (name.length < 2 || name.length > 100) {
          await client.sendMessage(senderId, "Por favor, digite um nome v√°lido (entre 2 e 100 caracteres).");
          break;
        }
        stateInfo.data.name = name;
        stateInfo.state = "awaiting_address";
        console.log(`[DADO] Nome recebido: ${name}`);
        console.log(`[ESTADO] Estado atualizado para awaiting_address para ${senderId}`);
        await client.sendMessage(
          senderId,
          `Obrigado, ${name}! Agora, por favor, me informe seu endere√ßo completo (Ex: Rua Exemplo, 123, Bairro, Cidade - UF).`
        );
        break;

      case "awaiting_address":
        const address = msg.body.trim();
        // Valida√ß√£o simples de endere√ßo (pode ser aprimorada com regex ou API de CEP)
        if (address.length < 10 || address.length > 255) {
          await client.sendMessage(senderId, "Por favor, digite um endere√ßo v√°lido e completo (entre 10 e 255 caracteres).");
          break;
        }
        stateInfo.data.address = address;
        stateInfo.state = "awaiting_address_confirmation";
        console.log(`[DADO] Endere√ßo recebido: ${address}`);
        console.log(`[ESTADO] Estado atualizado para awaiting_address_confirmation para ${senderId}`);
        
        const confirmationMessage = `Por favor, confirme seus dados:\n\nNome: ${stateInfo.data.name}\nEndere√ßo: ${stateInfo.data.address}\n\nOs dados est√£o corretos?\n1. Sim, salvar dados\n2. N√£o, corrigir nome\n3. N√£o, corrigir endere√ßo`;
        await client.sendMessage(senderId, confirmationMessage);
        break;

      case "awaiting_address_confirmation":
        const confirmationChoice = msg.body.trim();
        console.log(`[DADO] Escolha de confirma√ß√£o: ${confirmationChoice}`);
        switch (confirmationChoice) {
          case "1": // Sim, salvar dados
            try {
              const insertResult = await conn.query(
                "INSERT INTO clients (name, whatsapp_number, address) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE name = VALUES(name), address = VALUES(address), last_interaction_at = NOW()",
                [stateInfo.data.name, senderNumber, stateInfo.data.address]
              );
              currentClient = { id: insertResult.insertId || stateInfo.data.clientId, name: stateInfo.data.name, address: stateInfo.data.address }; // Atualiza currentClient
              console.log(
                `[DB] Cliente ${stateInfo.data.name} (ID: ${currentClient.id}) salvo/atualizado com sucesso.`
              );
              await showMainMenu(senderId, stateInfo.data.name);
            } catch (dbError) {
              console.error("[ERRO DB] Falha ao salvar cliente:", dbError);
              await client.sendMessage(
                senderId,
                "Desculpe, n√£o consegui salvar seus dados agora. Por favor, tente novamente mais tarde ou contate o suporte se o problema persistir."
              );
              delete userState[senderId]; // Limpa o estado para recome√ßar
            }
            break;
          case "2": // N√£o, corrigir nome
            stateInfo.state = "awaiting_name";
            delete stateInfo.data.name; // Remove o nome anterior para nova coleta
            console.log(`[ESTADO] Estado atualizado para awaiting_name (corre√ß√£o) para ${senderId}`);
            await client.sendMessage(senderId, "Ok, vamos corrigir seu nome. Qual √© o seu nome completo?");
            break;
          case "3": // N√£o, corrigir endere√ßo
            stateInfo.state = "awaiting_address";
            delete stateInfo.data.address; // Remove o endere√ßo anterior para nova coleta
            console.log(`[ESTADO] Estado atualizado para awaiting_address (corre√ß√£o) para ${senderId}`);
            await client.sendMessage(senderId, "Ok, vamos corrigir seu endere√ßo. Qual √© o seu endere√ßo completo (Rua, N√∫mero, Bairro, Cidade - UF)?");
            break;
          default:
            await client.sendMessage(senderId, "Op√ß√£o inv√°lida. Por favor, digite 1 para confirmar, 2 para corrigir o nome ou 3 para corrigir o endere√ßo.");
            break;
        }
        break;
        
      case "awaiting_welcome_choice":
        const welcomeChoice = msg.selectedButtonId || msg.body.trim();
        console.log(`[DADO] Escolha de boas-vindas: ${welcomeChoice}`);
        if (welcomeChoice === "main_menu" || welcomeChoice === "1") {
            await showMainMenu(senderId, stateInfo.data.name);
        } else if (welcomeChoice === "update_data" || welcomeChoice === "2") {
            stateInfo.state = "awaiting_data_update_choice";
            const updateOptions = new Buttons(
                `O que voc√™ gostaria de atualizar?`,
                [
                    {id: "update_name", body: "Atualizar Nome"},
                    {id: "update_address", body: "Atualizar Endere√ßo"},
                    {id: "cancel_update", body: "Cancelar"}
                ],
                "Atualizar Dados"
            );
            await client.sendMessage(senderId, updateOptions);
            console.log(`[ESTADO] Estado atualizado para awaiting_data_update_choice para ${senderId}`);
        } else {
            await client.sendMessage(senderId, "Op√ß√£o inv√°lida. Por favor, selecione uma das op√ß√µes.");
        }
        break;

      case "awaiting_data_update_choice":
        const updateFieldChoice = msg.selectedButtonId || msg.body.trim();
        console.log(`[DADO] Escolha de campo para atualizar: ${updateFieldChoice}`);
        switch (updateFieldChoice) {
            case "update_name":
            case "1":
                stateInfo.state = "awaiting_new_name";
                await client.sendMessage(senderId, "Qual √© o seu novo nome completo?");
                console.log(`[ESTADO] Estado atualizado para awaiting_new_name para ${senderId}`);
                break;
            case "update_address":
            case "2":
                stateInfo.state = "awaiting_new_address";
                await client.sendMessage(senderId, "Qual √© o seu novo endere√ßo completo (Rua, N√∫mero, Bairro, Cidade - UF)?");
                console.log(`[ESTADO] Estado atualizado para awaiting_new_address para ${senderId}`);
                break;
            case "cancel_update":
            case "3":
                await client.sendMessage(senderId, "Atualiza√ß√£o de dados cancelada.");
                await showMainMenu(senderId, stateInfo.data.name);
                break;
            default:
                await client.sendMessage(senderId, "Op√ß√£o inv√°lida. Por favor, selecione o que deseja atualizar ou cancele.");
                break;
        }
        break;

      case "awaiting_new_name":
        const newName = msg.body.trim();
        if (newName.length < 2 || newName.length > 100) {
            await client.sendMessage(senderId, "Por favor, digite um nome v√°lido (entre 2 e 100 caracteres).");
            break;
        }
        stateInfo.data.newName = newName;
        stateInfo.state = "awaiting_update_confirmation";
        const confirmNewNameMsg = `Confirmar novo nome: ${newName}?\n1. Sim\n2. N√£o, digitar novamente`;
        await client.sendMessage(senderId, confirmNewNameMsg);
        console.log(`[ESTADO] Estado atualizado para awaiting_update_confirmation (nome) para ${senderId}`);
        break;

      case "awaiting_new_address":
        const newAddress = msg.body.trim();
        if (newAddress.length < 10 || newAddress.length > 255) {
            await client.sendMessage(senderId, "Por favor, digite um endere√ßo v√°lido e completo (entre 10 e 255 caracteres).");
            break;
        }
        stateInfo.data.newAddress = newAddress;
        stateInfo.state = "awaiting_update_confirmation";
        const confirmNewAddressMsg = `Confirmar novo endere√ßo: ${newAddress}?\n1. Sim\n2. N√£o, digitar novamente`;
        await client.sendMessage(senderId, confirmNewAddressMsg);
        console.log(`[ESTADO] Estado atualizado para awaiting_update_confirmation (endere√ßo) para ${senderId}`);
        break;

      case "awaiting_update_confirmation":
        const updateConfirmChoice = msg.body.trim();
        if (updateConfirmChoice === "1") {
            let fieldToUpdate = "";
            let newValue = "";
            if (stateInfo.data.newName) {
                fieldToUpdate = "name";
                newValue = stateInfo.data.newName;
                stateInfo.data.name = newValue; // Atualiza o nome no estado local
            } else if (stateInfo.data.newAddress) {
                fieldToUpdate = "address";
                newValue = stateInfo.data.newAddress;
                stateInfo.data.address = newValue; // Atualiza o endere√ßo no estado local
            }

            if (fieldToUpdate) {
                try {
                    await conn.query(
                        `UPDATE clients SET ${fieldToUpdate} = ?, last_interaction_at = NOW() WHERE id = ?`,
                        [newValue, stateInfo.data.clientId]
                    );
                    await client.sendMessage(senderId, `Seu ${fieldToUpdate === 'name' ? 'nome' : 'endere√ßo'} foi atualizado com sucesso!`);
                    console.log(`[DB] ${fieldToUpdate} do cliente ${stateInfo.data.clientId} atualizado para ${newValue}`);
                    delete stateInfo.data.newName; // Limpa dados tempor√°rios
                    delete stateInfo.data.newAddress;
                    await showMainMenu(senderId, stateInfo.data.name);
                } catch (dbError) {
                    console.error(`[ERRO DB] Falha ao atualizar ${fieldToUpdate} do cliente:`, dbError);
                    await client.sendMessage(senderId, "Desculpe, n√£o consegui atualizar seus dados agora. Tente novamente mais tarde.");
                    delete userState[senderId];
                }
            }
        } else if (updateConfirmChoice === "2") {
            if (stateInfo.data.newName) {
                stateInfo.state = "awaiting_new_name";
                await client.sendMessage(senderId, "Ok, digite seu novo nome completo novamente.");
            } else if (stateInfo.data.newAddress) {
                stateInfo.state = "awaiting_new_address";
                await client.sendMessage(senderId, "Ok, digite seu novo endere√ßo completo novamente.");
            }
            delete stateInfo.data.newName;
            delete stateInfo.data.newAddress;
        } else {
            await client.sendMessage(senderId, "Op√ß√£o inv√°lida. Por favor, digite 1 para Sim ou 2 para N√£o.");
        }
        break;

      case "awaiting_menu_choice":
        // C√≥digo existente para tratamento do menu principal (omitido para brevidade)
        // ... (L√≥gica do menu principal)
        const choice = msg.body.trim();
        let nextState = null;
        let responseMessage = "";
        let interactionType = ""; // Para salvar no ticket

        switch (choice) {
          case "1": // Financeiro
            interactionType = "Financeiro";
            nextState = "awaiting_finance_choice";
            responseMessage =
              "Voc√™ escolheu Financeiro. O que voc√™ gostaria de fazer?\n\n1. Consultar Chave PIX\n2. Consultar Boletos Pendentes";
            break;
          case "2": // Agendamento
            interactionType = "Agendamento";
            nextState = "awaiting_specialty";
            const specialtiesList = await getSpecialties(conn); // Busca especialidades do DB
            let specialtyMenu = "Voc√™ escolheu Agendamento. Qual servi√ßo voc√™ precisa?\n\n";
            specialtiesList.forEach((spec, index) => {
                specialtyMenu += `${index + 1}. ${spec.name}\n`;
            });
            if (specialtiesList.length === 0) {
                specialtyMenu += "Nenhuma especialidade dispon√≠vel no momento.";
                 await client.sendMessage(senderId, specialtyMenu);
                 await showMainMenu(senderId, stateInfo.data.name);
                 return;
            }
            stateInfo.data.specialtiesList = specialtiesList.map(s => s.name); // Salva para valida√ß√£o
            responseMessage = specialtyMenu;
            break;
          case "3": // D√∫vidas / Falar com Atendente
            interactionType = "Suporte Atendente";
            try {
                const existingTicket = await conn.query(
                    "SELECT id, status FROM support_queue WHERE client_id = ? AND status IN ('waiting', 'in_progress')", 
                    [currentClient.id]
                );
                if (existingTicket.length > 0) {
                    if (existingTicket[0].status === 'waiting') {
                        const queuePosition = await conn.query(
                            "SELECT COUNT(*) as position FROM support_queue WHERE status = 'waiting' AND created_at <= (SELECT created_at FROM support_queue WHERE id = ?)",
                            [existingTicket[0].id]
                        );
                        responseMessage = `Voc√™ j√° est√° na fila de atendimento. Sua posi√ß√£o atual √©: ${queuePosition[0].position}. Por favor, aguarde.`;
                    } else {
                        responseMessage = "Voc√™ j√° est√° sendo atendido. Por favor, aguarde a resposta do atendente.";
                    }
                } else {
                    await conn.query(
                        "INSERT INTO support_queue (client_id, whatsapp_number, status) VALUES (?, ?, 'waiting')",
                        [currentClient.id, senderNumber]
                    );
                    const availableAttendants = await conn.query(
                        "SELECT whatsapp_number FROM attendants WHERE status = 'available'"
                    );
                    if (availableAttendants.length > 0) {
                        for (const attendant of availableAttendants) {
                            const attendantId = `${attendant.whatsapp_number}@c.us`;
                            await client.sendMessage(attendantId, `üîî Novo cliente na fila de atendimento: ${currentClient.name} (${senderNumber}). Use /falarcom ${senderNumber} para atender.`);
                        }
                        responseMessage = "Voc√™ escolheu D√∫vidas / Falar com Atendente. Voc√™ foi adicionado √† fila e um atendente ir√° contat√°-lo em breve.";
                    } else {
                        responseMessage = "Voc√™ escolheu D√∫vidas / Falar com Atendente. No momento, todos os nossos atendentes est√£o ocupados. Por favor, aguarde e voc√™ ser√° atendido assim que poss√≠vel.";
                    }
                }
            } catch (dbError) {
              console.error("[ERRO DB] Falha ao processar fila de atendimento:", dbError);
              responseMessage = "Voc√™ escolheu D√∫vidas / Falar com Atendente. Ocorreu um erro ao processar seu pedido. Por favor, tente novamente mais tarde.";
            }
            await client.sendMessage(senderId, responseMessage);
            if (conn) conn.release(); 
            return; 
          case "4": // Info Servi√ßos
            interactionType = "Info Servi√ßos";
            const servicesInfo = await getServicesInfo(conn); // Busca informa√ß√µes de servi√ßos do DB
            responseMessage = `Voc√™ escolheu Informa√ß√µes sobre Servi√ßos.\n\n${servicesInfo}\n\nPara mais detalhes, por favor, selecione a op√ß√£o de agendamento ou fale com um atendente.`;
            await client.sendMessage(senderId, responseMessage);
            await showThankYouAndRating(senderId, currentClient ? currentClient.id : null, interactionType, conn);
            if (conn) conn.release();
            return; 
          case "5": // Cancelar Agendamento
            interactionType = "Cancelamento";
            nextState = "awaiting_cancel_confirmation";
            try {
              const activeAppointments = await conn.query(
                "SELECT a.id, a.specialty, a.scheduled_datetime, a.period, a.google_calendar_event_id FROM appointments a WHERE a.client_id = ? AND a.status = 'scheduled' AND a.scheduled_datetime > NOW() ORDER BY a.scheduled_datetime ASC",
                [currentClient.id]
              );
              if (activeAppointments.length === 0) {
                await client.sendMessage(senderId, "Voc√™ n√£o possui agendamentos ativos para cancelar.");
                await showMainMenu(senderId, currentClient.name);
                if (conn) conn.release();
                return;
              }
              stateInfo.data.activeAppointments = activeAppointments;
              let appointmentList = "Agendamentos ativos:\n\n";
              activeAppointments.forEach((apt, index) => {
                const aptDate = new Date(apt.scheduled_datetime);
                appointmentList += `${index + 1}. ${apt.specialty} - ${aptDate.toLocaleDateString('pt-BR')} (${apt.period})\n`;
              });
              appointmentList += "\nDigite o n√∫mero do agendamento que deseja cancelar:";
              responseMessage = appointmentList;
            } catch (dbError) {
              console.error("[ERRO DB] Falha ao buscar agendamentos ativos:", dbError);
              await client.sendMessage(senderId, "Desculpe, n√£o consegui verificar seus agendamentos agora. Tente novamente mais tarde.");
              await showMainMenu(senderId, currentClient.name);
              if (conn) conn.release();
              return;
            }
            break;
          case "admin": 
            try {
              const isAdmin = await conn.query(
                "SELECT 1 FROM admin_users WHERE whatsapp_number = ?",
                [senderNumber]
              );
              if (isAdmin.length === 0) {
                await client.sendMessage(senderId, "Voc√™ n√£o tem permiss√£o para acessar comandos administrativos.");
                await showMainMenu(senderId, currentClient.name);
                if (conn) conn.release();
                return;
              }
              const adminMenu = 
                "üîß *Menu Administrativo*\n\n" +
                "1. Enviar lembretes para agendamentos de amanh√£\n" +
                "2. Voltar ao menu principal\n\n" +
                "Digite o n√∫mero da op√ß√£o desejada:";
              stateInfo.state = "awaiting_admin_choice";
              await client.sendMessage(senderId, adminMenu);
              if (conn) conn.release();
              return;
            } catch (dbError) {
              console.error("[ERRO DB] Falha ao verificar permiss√µes de administrador:", dbError);
              await client.sendMessage(senderId, "Desculpe, ocorreu um erro ao processar seu comando. Tente novamente mais tarde.");
              await showMainMenu(senderId, currentClient.name);
              if (conn) conn.release();
              return;
            }
            break;
          default:
            await client.sendMessage(
              senderId,
              "Op√ß√£o inv√°lida. Por favor, digite o n√∫mero de uma das op√ß√µes do menu."
            );
            await showMainMenu(senderId, currentClient ? currentClient.name : "Cliente");
            if (conn) conn.release();
            return;
        }

        if (interactionType && currentClient && currentClient.id) {
           try {
              await conn.query(
                  "INSERT INTO tickets (client_id, last_interaction_type, status) VALUES (?, ?, ?)",
                  [currentClient.id, interactionType, "open"]
              );
              console.log(`[DB] Novo ticket criado para cliente ${currentClient.id} com intera√ß√£o ${interactionType}`);
           } catch (ticketError) {
              console.error("[ERRO DB] Erro ao criar ticket: ", ticketError);
           }
        }

        if (nextState) {
          userState[senderId] = { ...stateInfo, state: nextState, data: { ...stateInfo.data, clientId: currentClient?.id, name: currentClient?.name, address: currentClient?.address } }; // Garante que clientId, name, address est√£o no data
          console.log(`[ESTADO] Estado atualizado para ${nextState} para ${senderId}`);
          await client.sendMessage(senderId, responseMessage);
        } else {
          console.warn(`[AVISO] nextState n√£o definido para escolha ${choice}, finalizando fluxo.`);
          await showThankYouAndRating(senderId, currentClient ? currentClient.id : null, interactionType, conn);
        }
        break;

      // --- Outros estados (Financeiro, Agendamento, etc. - c√≥digo existente omitido para brevidade) ---
      case "awaiting_finance_choice":
          const financeChoice = msg.body.trim();
          console.log(`[DADO] Op√ß√£o Financeiro: ${financeChoice}`);
          if (financeChoice === "1") { // Consultar PIX
              let pixKey = "Chave PIX n√£o configurada.";
              try {
                  const settingResult = await conn.query("SELECT value FROM config WHERE name = ?", ["pix_key"]);
                  if (settingResult.length > 0) pixKey = settingResult[0].value;
              } catch (e) { console.error("[ERRO DB] Erro ao buscar chave PIX", e); }
              await client.sendMessage(senderId, `Nossa chave PIX √©: ${pixKey}`);
              await showThankYouAndRating(senderId, currentClient?.id, "Consulta PIX", conn);
          } else if (financeChoice === "2") { // Consultar Boleto
              try {
                  const invoices = await conn.query("SELECT id, description, due_date, amount, pdf_url FROM boletos WHERE client_id = ? AND status = ? ORDER BY due_date ASC", [currentClient.id, "pending"]);
                  if (invoices.length === 0) {
                      await client.sendMessage(senderId, "Voc√™ n√£o possui boletos pendentes no momento.");
                      await showThankYouAndRating(senderId, currentClient?.id, "Consulta Boleto (Nenhum)", conn);
                  } else {
                      let invoiceList = "Boletos pendentes:\n";
                      invoices.forEach((inv, index) => {
                          invoiceList += `\n${index + 1}. ${inv.description} (Venc: ${new Date(inv.due_date).toLocaleDateString("pt-BR")}, R$ ${inv.amount.toFixed(2)})`;
                      });
                      invoiceList += "\n\nDigite o n√∫mero do boleto que deseja receber:";
                      userState[senderId] = { ...stateInfo, state: "awaiting_invoice_choice", data: { ...stateInfo.data, invoices: invoices } };
                      console.log(`[ESTADO] Estado atualizado para awaiting_invoice_choice para ${senderId}`);
                      await client.sendMessage(senderId, invoiceList);
                  }
              } catch (dbErr) {
                  console.error("[ERRO DB] Erro ao buscar boletos:", dbErr);
                  await client.sendMessage(senderId, "Desculpe, n√£o consegui consultar seus boletos agora. Tente novamente mais tarde.");
                  delete userState[senderId];
              }
          } else {
              await client.sendMessage(senderId, "Op√ß√£o inv√°lida. Por favor, digite 1 para PIX ou 2 para Boletos.");
          }
          break;

      case "awaiting_invoice_choice":
          const invoiceIndex = parseInt(msg.body.trim()) - 1;
          const userInvoices = stateInfo.data.invoices;
          if (userInvoices && invoiceIndex >= 0 && invoiceIndex < userInvoices.length) {
              const selectedInvoice = userInvoices[invoiceIndex];
              console.log(`[DADO] Boleto selecionado: ID ${selectedInvoice.id}`);
              if (selectedInvoice.pdf_url) {
                  try {
                      const media = await MessageMedia.fromUrl(selectedInvoice.pdf_url, { unsafeMime: true });
                      await client.sendMessage(senderId, `Aqui est√° o boleto para ${selectedInvoice.description}:`);
                      await client.sendMessage(senderId, media); // Envia a m√≠dia separadamente
                      console.log(`[INFO] PDF do boleto ${selectedInvoice.id} enviado para ${senderId}`);
                      await showThankYouAndRating(senderId, currentClient?.id, "Envio Boleto PDF", conn);
                  } catch (mediaError) {
                      console.error(`[ERRO M√çDIA] Falha ao buscar/enviar PDF do boleto ${selectedInvoice.id} da URL ${selectedInvoice.pdf_url}:`, mediaError);
                      await client.sendMessage(senderId, `Desculpe, n√£o consegui obter o PDF do boleto (${selectedInvoice.description}) no momento. Por favor, entre em contato com o suporte.`);
                      await showThankYouAndRating(senderId, currentClient?.id, "Envio Boleto PDF (Erro)", conn);
                  }
              } else {
                  await client.sendMessage(senderId, `O boleto selecionado (${selectedInvoice.description}) n√£o possui um arquivo PDF dispon√≠vel para envio autom√°tico. Por favor, entre em contato com o suporte.`);
                  console.log(`[INFO] Boleto ${selectedInvoice.id} sem PDF para ${senderId}`);
                  await showThankYouAndRating(senderId, currentClient?.id, "Envio Boleto (Sem PDF)", conn);
              }
          } else {
              await client.sendMessage(senderId, "N√∫mero de boleto inv√°lido. Por favor, digite o n√∫mero correspondente ao boleto desejado da lista anterior.");
          }
          break;

      case "awaiting_specialty":
          const specialtyChoiceIndex = parseInt(msg.body.trim()) - 1;
          const currentSpecialties = stateInfo.data.specialtiesList || [];
          if (specialtyChoiceIndex >= 0 && specialtyChoiceIndex < currentSpecialties.length) {
              const chosenSpecialty = currentSpecialties[specialtyChoiceIndex];
              stateInfo.data.specialty = chosenSpecialty;
              stateInfo.state = "awaiting_problem_description";
              console.log(`[DADO] Especialidade escolhida: ${chosenSpecialty}`);
              console.log(`[ESTADO] Estado atualizado para awaiting_problem_description para ${senderId}`);
              await client.sendMessage(senderId, `Entendido: ${chosenSpecialty}.\n\nAgora, por favor, descreva o problema ou o servi√ßo que voc√™ precisa. Se poss√≠vel, envie fotos para ajudar no diagn√≥stico.`);
          } else {
              await client.sendMessage(senderId, "Op√ß√£o de especialidade inv√°lida. Por favor, digite o n√∫mero correspondente.");
          }
          break;

      case "awaiting_problem_description":
          if (msg.type === "chat") {
              const messageText = msg.body.trim().toLowerCase();
              if (messageText === "pronto" || messageText === "finalizar" || messageText === "concluir") {
                  if (stateInfo.data.attachments && stateInfo.data.attachments.length > 0) {
                      if (!stateInfo.data.problemDescription) {
                          await client.sendMessage(senderId, "Entendi que voc√™ terminou de enviar fotos. Agora, por favor, descreva o problema ou servi√ßo que voc√™ precisa em texto.");
                          return;
                      } else {
                          stateInfo.state = "fetching_availability";
                          console.log(`[ESTADO] Estado atualizado para fetching_availability para ${senderId} ap√≥s finalizar fotos`);
                          await client.sendMessage(senderId, `Obrigado pelas ${stateInfo.data.attachments.length} foto(s) e pela descri√ß√£o. Vou verificar os hor√°rios dispon√≠veis na agenda. Isso pode levar um momento...`);
                          await fetchAndShowAvailability(senderId, stateInfo.data, conn);
                          return;
                      }
                  } else {
                      await client.sendMessage(senderId, "Voc√™ ainda n√£o enviou nenhuma foto. Por favor, envie fotos do problema ou descreva o problema em texto.");
                      return;
                  }
              }
              stateInfo.data.problemDescription = (stateInfo.data.problemDescription || "") + msg.body + "\n";
              console.log(`[DADO] Descri√ß√£o do problema atualizada: ${stateInfo.data.problemDescription}`);
              await client.sendMessage(senderId, "Descri√ß√£o recebida. Voc√™ pode adicionar mais detalhes, enviar fotos ou digitar 'pronto' para prosseguir com o agendamento.");
          
          } else if (msg.type === "image" || msg.type === "video") {
              try {
                  const media = await msg.downloadMedia();
                  if (!media || !media.data) {
                      await client.sendMessage(senderId, "N√£o foi poss√≠vel processar esta m√≠dia. Tente novamente.");
                      return;
                  }
                  if (!stateInfo.data.attachments) stateInfo.data.attachments = [];
                  stateInfo.data.attachments.push({ filename: media.filename, mimetype: media.mimetype, data: media.data });
                  console.log(`[DADO] M√≠dia recebida: ${media.filename || 'sem nome'} (${stateInfo.data.attachments.length} anexos)`);
                  await client.sendMessage(senderId, `Foto/v√≠deo recebido (${stateInfo.data.attachments.length}). Envie mais ou digite 'pronto' para finalizar o envio de m√≠dias e descrever o problema (se ainda n√£o o fez).`);
              } catch (mediaError) {
                  console.error("[ERRO M√çDIA] Falha ao baixar m√≠dia:", mediaError);
                  await client.sendMessage(senderId, "Ocorreu um erro ao processar a m√≠dia. Tente novamente.");
              }
          } else {
              await client.sendMessage(senderId, "Por favor, descreva o problema, envie fotos ou digite 'pronto' para prosseguir.");
          }
          break;

      case "fetching_availability":
          // Este estado √© apenas para indicar que estamos buscando, a l√≥gica est√° em fetchAndShowAvailability
          await client.sendMessage(senderId, "Ainda estou verificando a disponibilidade. S√≥ um momento...");
          break;

      case "awaiting_schedule_choice":
          const scheduleChoice = msg.body.trim();
          const availableSlots = stateInfo.data.availableSlots;
          const chosenSlotIndex = parseInt(scheduleChoice) - 1;

          if (availableSlots && chosenSlotIndex >= 0 && chosenSlotIndex < availableSlots.length) {
              const chosenSlot = availableSlots[chosenSlotIndex];
              stateInfo.data.chosenSlot = chosenSlot;
              stateInfo.state = "awaiting_schedule_confirmation";
              console.log(`[DADO] Hor√°rio escolhido: ${chosenSlot.date} ${chosenSlot.time}`);
              console.log(`[ESTADO] Estado atualizado para awaiting_schedule_confirmation para ${senderId}`);
              await client.sendMessage(senderId, `Voc√™ escolheu: ${chosenSlot.date} √†s ${chosenSlot.time} (${chosenSlot.period}).\n\nConfirma o agendamento?\n1. Sim\n2. N√£o, escolher outro hor√°rio`);
          } else {
              await client.sendMessage(senderId, "Op√ß√£o de hor√°rio inv√°lida. Por favor, digite o n√∫mero correspondente ao hor√°rio desejado.");
          }
          break;

      case "awaiting_schedule_confirmation":
          const scheduleConfirmChoice = msg.body.trim();
          if (scheduleConfirmChoice === "1") {
              try {
                  const appointmentData = {
                      clientId: currentClient.id,
                      specialty: stateInfo.data.specialty,
                      problemDescription: stateInfo.data.problemDescription,
                      scheduledDatetime: `${stateInfo.data.chosenSlot.date} ${stateInfo.data.chosenSlot.time}`,
                      period: stateInfo.data.chosenSlot.period,
                      status: "scheduled",
                      visitFee: stateInfo.data.visitFee || 50.00 // Usar taxa de visita do estado ou padr√£o
                  };

                  // Salvar agendamento no Google Calendar
                  const event = await createGoogleCalendarEvent(appointmentData, currentClient.name, currentClient.address);
                  appointmentData.google_calendar_event_id = event.id;
                  
                  // Salvar agendamento no banco de dados
                  const result = await conn.query(
                      "INSERT INTO appointments (client_id, specialty, problem_description, scheduled_datetime, period, status, visit_fee, google_calendar_event_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                      [appointmentData.clientId, appointmentData.specialty, appointmentData.problemDescription, appointmentData.scheduledDatetime, appointmentData.period, appointmentData.status, appointmentData.visitFee, appointmentData.google_calendar_event_id]
                  );
                  const appointmentId = result.insertId;
                  console.log(`[DB] Agendamento ${appointmentId} salvo com sucesso.`);

                  // Salvar anexos, se houver
                  if (stateInfo.data.attachments && stateInfo.data.attachments.length > 0) {
                      for (const attachment of stateInfo.data.attachments) {
                          const attachmentPath = await saveAttachment(appointmentId, attachment, conn);
                          console.log(`[ANEXO] Anexo salvo em ${attachmentPath} para agendamento ${appointmentId}`);
                      }
                  }
                  
                  // Atribuir t√©cnico, se poss√≠vel
                  const assignedTechnician = await assignTechnicianToAppointment(appointmentId, appointmentData.scheduledDatetime, conn);
                  let technicianMessage = "";
                  if (assignedTechnician) {
                      technicianMessage = `\n\nO t√©cnico ${assignedTechnician.name} foi pr√©-atribu√≠do para o seu servi√ßo.`;
                      // Notificar t√©cnico (opcional, pode ser feito por outro sistema/processo)
                  }

                  await client.sendMessage(senderId, `Agendamento confirmado para ${stateInfo.data.chosenSlot.date} √†s ${stateInfo.data.chosenSlot.time} (${stateInfo.data.chosenSlot.period}). ${technicianMessage}\n\nObrigado!`);
                  await showThankYouAndRating(senderId, currentClient.id, "Agendamento Confirmado", conn);
              } catch (error) {
                  console.error("[ERRO] Falha ao confirmar agendamento:", error);
                  await client.sendMessage(senderId, "Desculpe, ocorreu um erro ao confirmar seu agendamento. Por favor, tente novamente ou contate o suporte.");
                  delete userState[senderId];
              }
          } else if (scheduleConfirmChoice === "2") {
              stateInfo.state = "fetching_availability"; // Volta para buscar hor√°rios
              console.log(`[ESTADO] Estado atualizado para fetching_availability (reagendamento) para ${senderId}`);
              await client.sendMessage(senderId, "Ok, vamos buscar outros hor√°rios dispon√≠veis...");
              await fetchAndShowAvailability(senderId, stateInfo.data, conn);
          } else {
              await client.sendMessage(senderId, "Op√ß√£o inv√°lida. Por favor, digite 1 para Sim ou 2 para N√£o.");
          }
          break;

      case "awaiting_cancel_confirmation":
          const cancelChoiceIndex = parseInt(msg.body.trim()) - 1;
          const appointmentsToCancel = stateInfo.data.activeAppointments;

          if (appointmentsToCancel && cancelChoiceIndex >= 0 && cancelChoiceIndex < appointmentsToCancel.length) {
              const appointmentToCancel = appointmentsToCancel[cancelChoiceIndex];
              try {
                  // Cancelar no Google Calendar
                  if (appointmentToCancel.google_calendar_event_id) {
                      await calendar.events.delete({
                          calendarId: CALENDAR_ID,
                          eventId: appointmentToCancel.google_calendar_event_id,
                      });
                      console.log(`[GCAL] Evento ${appointmentToCancel.google_calendar_event_id} cancelado no Google Calendar.`);
                  }

                  // Atualizar status no banco de dados
                  await conn.query(
                      "UPDATE appointments SET status = ? WHERE id = ?",
                      ["cancelled_by_client", appointmentToCancel.id]
                  );
                  console.log(`[DB] Agendamento ${appointmentToCancel.id} cancelado pelo cliente.`);
                  await client.sendMessage(senderId, `O agendamento de ${appointmentToCancel.specialty} para ${new Date(appointmentToCancel.scheduled_datetime).toLocaleDateString('pt-BR')} foi cancelado com sucesso.`);
                  await showThankYouAndRating(senderId, currentClient.id, "Cancelamento Confirmado", conn);
              } catch (error) {
                  console.error("[ERRO] Falha ao cancelar agendamento:", error);
                  await client.sendMessage(senderId, "Desculpe, ocorreu um erro ao cancelar seu agendamento. Por favor, tente novamente ou contate o suporte.");
                  delete userState[senderId];
              }
          } else {
              await client.sendMessage(senderId, "N√∫mero de agendamento inv√°lido. Por favor, digite o n√∫mero correspondente ao agendamento que deseja cancelar.");
          }
          break;

      case "awaiting_rating":
          const rating = parseInt(msg.body.trim());
          if (rating >= 1 && rating <= 5) {
              try {
                  await conn.query(
                      "INSERT INTO reviews (client_id, rating, review_type, related_id) VALUES (?, ?, ?, ?)",
                      [stateInfo.data.clientId, rating, stateInfo.data.reviewType, stateInfo.data.attendantId || stateInfo.data.serviceOrderId || null]
                  );
                  console.log(`[DB] Avalia√ß√£o (${rating} estrelas) salva para cliente ${stateInfo.data.clientId}`);
                  await client.sendMessage(senderId, "Obrigado pela sua avalia√ß√£o! Sua opini√£o √© muito importante para n√≥s.");
                  delete userState[senderId]; // Finaliza o fluxo de avalia√ß√£o
              } catch (dbError) {
                  console.error("[ERRO DB] Falha ao salvar avalia√ß√£o:", dbError);
                  await client.sendMessage(senderId, "Desculpe, n√£o consegui salvar sua avalia√ß√£o agora. Agradecemos de qualquer forma!");
                  delete userState[senderId];
              }
          } else {
              await client.sendMessage(senderId, "Avalia√ß√£o inv√°lida. Por favor, digite um n√∫mero de 1 a 5.");
          }
          break;

      case "awaiting_admin_choice":
          const adminChoice = msg.body.trim();
          if (adminChoice === "1") {
              await client.sendMessage(senderId, "Iniciando envio de lembretes para agendamentos de amanh√£...");
              await sendAppointmentReminders(conn, client);
          } else if (adminChoice === "2") {
              await showMainMenu(senderId, currentClient.name);
          } else {
              await client.sendMessage(senderId, "Op√ß√£o administrativa inv√°lida.");
          }
          break;

      default:
        console.log(`[AVISO] Estado desconhecido ou n√£o tratado: ${stateInfo.state}`);
        await client.sendMessage(senderId, "Desculpe, n√£o entendi. Vamos tentar novamente.");
        delete userState[senderId]; // Limpa estado para recome√ßar
        await showMainMenu(senderId, currentClient ? currentClient.name : "Cliente");
        break;
    }
  }
  if (conn) conn.release();
});

// --- Fun√ß√µes Auxiliares ---
async function showMainMenu(senderId, clientName) {
  const greeting = clientName ? `Ol√° ${clientName}, ` : "";
  const menuMessage = `${greeting}Como posso te ajudar hoje?\n\n1. Financeiro (PIX, Boletos)
2. Agendar Servi√ßo T√©cnico
3. D√∫vidas / Falar com Atendente
4. Informa√ß√µes sobre Servi√ßos
5. Cancelar Agendamento\n\nDigite o n√∫mero da op√ß√£o desejada:`;
  
  userState[senderId] = { state: "awaiting_menu_choice", data: { name: clientName } }; // Salva o nome para uso futuro
  console.log(`[ESTADO] Estado atualizado para awaiting_menu_choice para ${senderId}`);
  await client.sendMessage(senderId, menuMessage);
}

async function showThankYouAndRating(senderId, clientId, interactionType, dbConnection) {
    let conn = dbConnection;
    let connectionReleased = false;
    try {
        if (!conn) {
            conn = await pool.getConnection();
        } else {
            connectionReleased = true; // Indica que a conex√£o foi passada e n√£o deve ser liberada aqui
        }

        // Atualizar last_interaction_type e last_interaction_at
        if (clientId && interactionType) {
            await conn.query(
                "UPDATE clients SET last_interaction_type = ?, last_interaction_at = NOW() WHERE id = ?",
                [interactionType, clientId]
            );
            console.log(`[DB] √öltima intera√ß√£o do cliente ${clientId} atualizada para: ${interactionType}`);
        }

        const dailyPhraseResult = await conn.query("SELECT phrase FROM daily_phrases ORDER BY RAND() LIMIT 1");
        const dailyPhrase = dailyPhraseResult.length > 0 ? dailyPhraseResult[0].phrase : "Agradecemos seu contato!";

        await client.sendMessage(senderId, `${dailyPhrase}\n\nComo voc√™ avalia este atendimento/intera√ß√£o? (Digite um n√∫mero de 1 a 5 estrelas)`);
        userState[senderId] = { state: "awaiting_rating", data: { clientId: clientId, reviewType: interactionType } };
        console.log(`[ESTADO] Estado atualizado para awaiting_rating para ${senderId} (Intera√ß√£o: ${interactionType})`);
    } catch (error) {
        console.error("[ERRO] Falha ao mostrar agradecimento/avalia√ß√£o:", error);
        await client.sendMessage(senderId, "Obrigado pelo seu contato!");
        delete userState[senderId];
    } finally {
        if (conn && !connectionReleased) {
            conn.release();
        }
    }
}

async function getSpecialties(conn) {
    try {
        const specialties = await conn.query("SELECT id, name, description, base_visit_fee FROM specialties WHERE active = 1 ORDER BY name ASC");
        return specialties;
    } catch (error) {
        console.error("[ERRO DB] Falha ao buscar especialidades:", error);
        return [];
    }
}

async function getServicesInfo(conn) {
    try {
        const services = await conn.query("SELECT name, description FROM services_info WHERE active = 1 ORDER BY display_order ASC");
        if (services.length === 0) return "Nenhuma informa√ß√£o de servi√ßo dispon√≠vel no momento.";
        return services.map(s => `*${s.name}*:\n${s.description}`).join("\n\n");
    } catch (error) {
        console.error("[ERRO DB] Falha ao buscar informa√ß√µes de servi√ßos:", error);
        return "Ocorreu um erro ao buscar informa√ß√µes de servi√ßos.";
    }
}

async function fetchAndShowAvailability(senderId, data, dbConnection) {
    let conn = dbConnection;
    let connectionReleased = false;
    try {
        if (!conn) {
            conn = await pool.getConnection();
        } else {
            connectionReleased = true; 
        }

        const specialtyName = data.specialty;
        const specialtyDetails = await conn.query("SELECT id, base_visit_fee FROM specialties WHERE name = ?", [specialtyName]);
        const visitFee = specialtyDetails.length > 0 ? specialtyDetails[0].base_visit_fee : 50.00; // Taxa padr√£o se n√£o encontrada
        data.visitFee = visitFee; // Salva a taxa de visita no estado

        // Simula√ß√£o de busca de hor√°rios (substituir pela l√≥gica real com Google Calendar)
        const today = new Date();
        const availableSlots = [];
        for (let i = 1; i <= 7; i++) { // Pr√≥ximos 7 dias
            const day = new Date(today);
            day.setDate(today.getDate() + i);
            if (day.getDay() === 0 || day.getDay() === 6) continue; // Pular S√°b/Dom

            const dateStr = day.toISOString().split('T')[0];
            availableSlots.push({ date: dateStr, time: "09:00", period: "Manh√£" });
            availableSlots.push({ date: dateStr, time: "14:00", period: "Tarde" });
        }

        if (availableSlots.length === 0) {
            await client.sendMessage(senderId, "Desculpe, n√£o h√° hor√°rios dispon√≠veis para esta especialidade nos pr√≥ximos dias. Por favor, tente mais tarde ou contate o suporte.");
            await showMainMenu(senderId, data.name);
            return;
        }

        let slotsMessage = `Hor√°rios dispon√≠veis para *${data.specialty}* (Taxa de visita: R$ ${visitFee.toFixed(2)}):\n\n`;
        availableSlots.forEach((slot, index) => {
            slotsMessage += `${index + 1}. ${new Date(slot.date + 'T' + slot.time).toLocaleDateString('pt-BR', { weekday: 'long', day: '2-digit', month: '2-digit' })} √†s ${slot.time} (${slot.period})\n`;
        });
        slotsMessage += "\nDigite o n√∫mero do hor√°rio desejado:";

        userState[senderId] = { ...userState[senderId], state: "awaiting_schedule_choice", data: { ...data, availableSlots: availableSlots } };
        console.log(`[ESTADO] Estado atualizado para awaiting_schedule_choice para ${senderId}`);
        await client.sendMessage(senderId, slotsMessage);
    } catch (error) {
        console.error("[ERRO] Falha ao buscar disponibilidade:", error);
        await client.sendMessage(senderId, "Desculpe, ocorreu um erro ao verificar a disponibilidade. Tente novamente mais tarde.");
        delete userState[senderId];
    } finally {
        if (conn && !connectionReleased) {
            conn.release();
        }
    }
}

async function createGoogleCalendarEvent(appointmentData, clientName, clientAddress) {
    const startDateTime = new Date(appointmentData.scheduledDatetime);
    const endDateTime = new Date(startDateTime.getTime() + (60 * 60 * 1000)); // Assume 1 hora de dura√ß√£o

    const event = {
        summary: `Servi√ßo: ${appointmentData.specialty} - Cliente: ${clientName}`,
        location: clientAddress || 'Endere√ßo n√£o informado',
        description: `Problema: ${appointmentData.problemDescription}\nPer√≠odo: ${appointmentData.period}\nTaxa de Visita: R$ ${appointmentData.visitFee.toFixed(2)}`,
        start: {
            dateTime: startDateTime.toISOString(),
            timeZone: 'America/Sao_Paulo',
        },
        end: {
            dateTime: endDateTime.toISOString(),
            timeZone: 'America/Sao_Paulo',
        },
        reminders: {
            useDefault: false,
            overrides: [
                { method: 'email', minutes: 24 * 60 }, // Lembrete por email 1 dia antes
                { method: 'popup', minutes: 60 },      // Lembrete no app 1 hora antes
            ],
        },
    };

    try {
        const createdEvent = await calendar.events.insert({
            calendarId: CALENDAR_ID,
            resource: event,
        });
        console.log('[GCAL] Evento criado: %s', createdEvent.data.htmlLink);
        return createdEvent.data;
    } catch (error) {
        console.error('[GCAL ERRO] Erro ao criar evento no Google Calendar:', error);
        throw new Error('Falha ao criar evento no Google Calendar'); // Propaga o erro
    }
}

async function saveAttachment(appointmentId, attachment, conn) {
    const uploadDir = path.join(__dirname, 'uploads', 'appointments', appointmentId.toString());
    if (!fs.existsSync(uploadDir)) {
        fs.mkdirSync(uploadDir, { recursive: true });
    }
    const timestamp = new Date().getTime();
    const extension = attachment.mimetype.split('/')[1] || 'bin';
    const fileName = `attachment_${timestamp}.${extension}`;
    const filePath = path.join(uploadDir, fileName);
    const relativePath = path.join('uploads', 'appointments', appointmentId.toString(), fileName);

    try {
        const fileData = attachment.data.replace(/^data:[\w/]+;base64,/, '');
        fs.writeFileSync(filePath, Buffer.from(fileData, 'base64'));
        await conn.query(
            "INSERT INTO appointment_attachments (appointment_id, file_path, file_type, original_filename) VALUES (?, ?, ?, ?)",
            [appointmentId, relativePath, attachment.mimetype, attachment.filename || fileName]
        );
        return relativePath;
    } catch (error) {
        console.error("[ERRO ANEXO] Falha ao salvar anexo:", error);
        throw error; // Propaga o erro
    }
}

async function assignTechnicianToAppointment(appointmentId, scheduledDatetime, conn) {
    try {
        // L√≥gica simples: busca um t√©cnico dispon√≠vel aleatoriamente.
        // Pode ser aprimorada para considerar especialidade, localiza√ß√£o, carga de trabalho, etc.
        const availableTechnicians = await conn.query(
            "SELECT id, name FROM technicians WHERE status = 'available' ORDER BY RAND() LIMIT 1"
        );

        if (availableTechnicians.length > 0) {
            const technician = availableTechnicians[0];
            await conn.query(
                "INSERT INTO service_orders (appointment_id, technician_id, status) VALUES (?, ?, 'assigned')",
                [appointmentId, technician.id]
            );
            console.log(`[DB] T√©cnico ${technician.name} (ID: ${technician.id}) atribu√≠do √† OS do agendamento ${appointmentId}`);
            return technician;
        }
        console.log(`[INFO] Nenhum t√©cnico dispon√≠vel para atribuir ao agendamento ${appointmentId}`);
        return null;
    } catch (error) {
        console.error("[ERRO DB] Falha ao atribuir t√©cnico:", error);
        return null;
    }
}

async function sendAppointmentReminders(conn, whatsappClient) {
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    const tomorrowStart = tomorrow.toISOString().split('T')[0] + " 00:00:00";
    const tomorrowEnd = tomorrow.toISOString().split('T')[0] + " 23:59:59";

    try {
        const appointments = await conn.query(
            `SELECT a.id, a.specialty, a.scheduled_datetime, a.period, 
                    c.name as client_name, c.whatsapp_number as client_whatsapp,
                    t.name as technician_name, t.whatsapp_number as technician_whatsapp
             FROM appointments a 
             JOIN clients c ON a.client_id = c.id 
             LEFT JOIN service_orders so ON a.id = so.appointment_id
             LEFT JOIN technicians t ON so.technician_id = t.id
             WHERE a.status = 'scheduled' AND a.scheduled_datetime BETWEEN ? AND ?`,
            [tomorrowStart, tomorrowEnd]
        );

        if (appointments.length === 0) {
            console.log("[LEMBRETE] Nenhum agendamento para amanh√£.");
            await whatsappClient.sendMessage(SERVICE_ACCOUNT_KEY_PATH, "Nenhum agendamento encontrado para enviar lembretes amanh√£."); // Envia para admin
            return;
        }

        let remindersSent = 0;
        for (const apt of appointments) {
            const clientMessage = 
                `Ol√° ${apt.client_name}! Lembrete do seu agendamento de *${apt.specialty}* amanh√£, ${new Date(apt.scheduled_datetime).toLocaleDateString('pt-BR')}, no per√≠odo da ${apt.period}.` +
                (apt.technician_name ? `\nSeu t√©cnico ser√° ${apt.technician_name}.` : "") +
                `\n\nPor favor, confirme sua presen√ßa respondendo "SIM" ou contate-nos para reagendar.`;
            
            const clientWppId = `${apt.client_whatsapp}@c.us`;
            try {
                await whatsappClient.sendMessage(clientWppId, clientMessage);
                console.log(`[LEMBRETE] Lembrete enviado para cliente ${apt.client_name} (${clientWppId})`);
                remindersSent++;
            } catch (e) {
                console.error(`[ERRO LEMBRETE] Falha ao enviar lembrete para ${clientWppId}:`, e.message);
            }

            // Opcional: Enviar lembrete para o t√©cnico
            if (apt.technician_whatsapp) {
                const techMessage = `Ol√° ${apt.technician_name}, voc√™ tem um servi√ßo de *${apt.specialty}* agendado para amanh√£, ${new Date(apt.scheduled_datetime).toLocaleDateString('pt-BR')} (${apt.period}), com o cliente ${apt.client_name}.`;
                const techWppId = `${apt.technician_whatsapp}@c.us`;
                 try {
                    await whatsappClient.sendMessage(techWppId, techMessage);
                    console.log(`[LEMBRETE] Lembrete enviado para t√©cnico ${apt.technician_name} (${techWppId})`);
                } catch (e) {
                    console.error(`[ERRO LEMBRETE] Falha ao enviar lembrete para t√©cnico ${techWppId}:`, e.message);
                }
            }
        }
        console.log(`[LEMBRETE] Total de ${remindersSent} lembretes enviados para clientes.`);
        await whatsappClient.sendMessage(SERVICE_ACCOUNT_KEY_PATH, `Total de ${remindersSent} lembretes de agendamento enviados para clientes.`); // Envia para admin

    } catch (error) {
        console.error("[ERRO DB] Falha ao buscar agendamentos para lembretes:", error);
        await whatsappClient.sendMessage(SERVICE_ACCOUNT_KEY_PATH, "Ocorreu um erro ao tentar enviar os lembretes de agendamento."); // Envia para admin
    }
}


// --- Inicializa√ß√£o do Cliente ---
console.log("[INFO] Inicializando cliente WhatsApp...");
client.initialize().catch(err => {
    console.error("[ERRO INICIALIZA√á√ÉO] Falha ao inicializar o cliente WhatsApp:", err);
    // Tentar limpar sess√£o e reiniciar se houver erro de autentica√ß√£o persistente
    if (err.message && err.message.includes("Protocol error (Runtime.callFunctionOn)")) {
        console.log("[INFO] Tentando limpar sess√£o e reiniciar...");
        const sessionDir = path.join(__dirname, ".wwebjs_auth");
        if (fs.existsSync(sessionDir)) {
            fs.rmSync(sessionDir, { recursive: true, force: true });
            console.log("[INFO] Diret√≥rio de sess√£o removido. Reinicie o bot.");
        }
    }
});

