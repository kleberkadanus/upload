
const qrcodeTerminal = require("qrcode-terminal");
const qrcode = require("qrcode");
const fs = require("fs");
const { Client, LocalAuth, MessageMedia, List, Buttons } = require("whatsapp-web.js");
const mariadb = require("mariadb");
const { google } = require("googleapis");
const path = require("path");
const { Client: GoogleMapsClient } = require('@googlemaps/google-maps-services-js');

// --- Database Configuration ---
const pool = mariadb.createPool({
  host: "104.234.30.102",
  user: "root",
  password: "+0q)3E3.G]Yu",
  database: "WTS2",
  connectionLimit: 5,
  connectTimeout: 15000,
  acquireTimeout: 15000,
});

// --- Google Calendar Configuration ---
const CALENDAR_SCOPES = ["https://www.googleapis.com/auth/calendar"];
const SERVICE_ACCOUNT_KEY_PATH = path.join(__dirname, "service_account.json");
const CALENDAR_ID = "kleberkadanus94@gmail.com"; // Agenda principal do usu√°rio

const googleAuth = new google.auth.GoogleAuth({
  keyFile: SERVICE_ACCOUNT_KEY_PATH,
  scopes: CALENDAR_SCOPES,
});

const calendar = google.calendar({ version: "v3", auth: googleAuth });

// --- WhatsApp Client Setup ---
const client = new Client({
  authStrategy: new LocalAuth(),
  puppeteer: {
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
  },
});

// Store conversation state for each user { senderId: { state: ..., data: {} } }
const userState = {};
const QR_FILE_PATH = "/home/ubuntu/whatsapp_bot_project/qrcode.png";

client.on("qr", (qr) => {
  console.log("[EVENTO QR] QR Code recebido. Tentando salvar como imagem...");
  qrcode.toFile(QR_FILE_PATH, qr, { errorCorrectionLevel: "H" }, function (err) {
    if (err) {
      console.error("[ERRO QR] Erro ao salvar QR code como imagem:", err);
      console.log(
        "[QR ALTERNATIVO] Exibindo QR code no terminal (pode ser grande):"
      );
      qrcodeTerminal.generate(qr, { small: true });
    } else {
      console.log(`[QR SALVO] QR Code salvo como imagem em: ${QR_FILE_PATH}`);
      console.log(
        "[A√á√ÉO NECESS√ÅRIA] Pe√ßa ao seu assistente (Manus) para enviar o arquivo qrcode.png para voc√™."
      );
    }
  });
});

client.on("ready", () => {
  console.log("[EVENTO READY] Cliente WhatsApp est√° pronto!");
  if (fs.existsSync(QR_FILE_PATH)) {
    try {
        fs.unlinkSync(QR_FILE_PATH);
        console.log(`[INFO] Arquivo QR code (${QR_FILE_PATH}) removido ap√≥s conex√£o.`);
    } catch (unlinkErr) {
        console.error(`[ERRO] Falha ao remover arquivo QR code: ${unlinkErr.message}`);
    }
  }
});

client.on("auth_failure", (msg) => {
  console.error("[EVENTO AUTH_FAILURE] Falha na autentica√ß√£o:", msg);
});

client.on("disconnected", (reason) => {
  console.log("[EVENTO DISCONNECTED] Cliente foi desconectado:", reason);
});

// --- Message Handling Logic ---
client.on("message", async (msg) => {
  const chat = await msg.getChat();
  const contact = await msg.getContact();
  const senderNumber = contact.id.user;
  const senderId = contact.id._serialized;

  console.log(
    `[MSG RECEBIDA] De: ${senderNumber} (${contact.pushname || "N/A"}) | Chat: ${chat.id.user} | Tipo: ${msg.type} | Corpo: ${msg.body}`
  );

  if (chat.isGroup || msg.isStatus) {
    console.log("[INFO] Ignorando msg de grupo/status.");
    return;
  }
  
  // Verificar se √© um comando de atendente
  if (msg.body.startsWith('/')) {
    const commandParts = msg.body.split(' ');
    const command = commandParts[0].toLowerCase();
    const params = commandParts.slice(1).join(' ');
    
    // Verificar se o remetente √© um atendente
    let conn = await pool.getConnection();
    try {
      const isAttendant = await conn.query(
        "SELECT id, name FROM attendants WHERE whatsapp_number = ?",
        [senderNumber]
      );
      
      if (isAttendant.length > 0) {
        const attendantId = isAttendant[0].id;
        const attendantName = isAttendant[0].name;
        
        // Atualizar status do atendente para dispon√≠vel
        await conn.query(
          "UPDATE attendants SET status = 'available', last_activity = NOW() WHERE id = ?",
          [attendantId]
        );
        
        // Processar comandos de atendente
        switch (command) {
          case '/finalizar':
            // Verificar se o atendente tem algum atendimento em andamento
            const activeTickets = await conn.query(
              "SELECT sq.id, sq.whatsapp_number, c.name, c.id as client_id FROM support_queue sq JOIN clients c ON sq.client_id = c.id WHERE sq.assigned_to = ? AND sq.status = 'in_progress'",
              [attendantId]
            );
            
            if (activeTickets.length === 0) {
              await client.sendMessage(senderId, "Voc√™ n√£o possui nenhum atendimento em andamento para finalizar.");
              break;
            }
            
            // Finalizar todos os atendimentos ativos deste atendente
            for (const ticket of activeTickets) {
              await conn.query(
                "UPDATE support_queue SET status = 'completed' WHERE id = ?",
                [ticket.id]
              );
              
              // Notificar cliente que o atendimento foi finalizado
              const clientId = `${ticket.whatsapp_number}@c.us`;
              await client.sendMessage(
                clientId,
                `Seu atendimento com ${attendantName} foi finalizado. Agradecemos o contato!\n\nComo voc√™ avalia o atendimento recebido? (Digite um n√∫mero de 1 a 5 estrelas)`
              );
              
              // Configurar estado do cliente para avalia√ß√£o
              if (!userState[clientId]) {
                userState[clientId] = { state: "awaiting_rating", data: {} };
              } else {
                userState[clientId].state = "awaiting_rating";
              }
              userState[clientId].data = {
                clientId: ticket.client_id,
                reviewType: "attendant_support",
                attendantId: attendantId
              };
            }
            
            // Verificar se h√° clientes na fila de espera
            const waitingClients = await conn.query(
              "SELECT sq.id, sq.whatsapp_number, c.id as client_id, c.name FROM support_queue sq JOIN clients c ON sq.client_id = c.id WHERE sq.status = 'waiting' ORDER BY sq.created_at ASC LIMIT 1"
            );
            
            if (waitingClients.length > 0) {
              const nextClient = waitingClients[0];
              
              // Atribuir pr√≥ximo cliente da fila para este atendente
              await conn.query(
                "UPDATE support_queue SET status = 'in_progress', assigned_to = ? WHERE id = ?",
                [attendantId, nextClient.id]
              );
              
              // Notificar atendente sobre o pr√≥ximo cliente
              const clientInfo = `Nome: ${nextClient.name}\nTelefone: ${nextClient.whatsapp_number}`;
              await client.sendMessage(
                senderId,
                `‚úÖ Atendimento(s) anterior(es) finalizado(s).\n\nüîî *Pr√≥ximo Cliente na Fila*\n\n${clientInfo}\n\nPara iniciar a conversa, use o comando:\n/falarcom ${nextClient.whatsapp_number}`
              );
              
              // Notificar cliente que ser√° atendido
              const nextClientId = `${nextClient.whatsapp_number}@c.us`;
              await client.sendMessage(
                nextClientId,
                `Ol√°! O atendente ${attendantName} est√° dispon√≠vel e ir√° atend√™-lo em instantes.`
              );
            } else {
              // N√£o h√° mais clientes na fila
              await client.sendMessage(
                senderId,
                "‚úÖ Atendimento(s) finalizado(s). N√£o h√° mais clientes na fila de espera."
              );
              
              // Atualizar status do atendente para dispon√≠vel
              await conn.query(
                "UPDATE attendants SET status = 'available' WHERE id = ?",
                [attendantId]
              );
            }
            break;
            
          case '/falarcom':
            if (!params) {
              await client.sendMessage(senderId, "Por favor, forne√ßa o n√∫mero do cliente. Exemplo: /falarcom 5541999999999");
              break;
            }
            
            const clientNumber = params.trim();
            const clientId = `${clientNumber}@c.us`;
            
            // Verificar se o cliente existe no banco
            const clientExists = await conn.query(
              "SELECT id, name FROM clients WHERE whatsapp_number = ?",
              [clientNumber]
            );
            
            if (clientExists.length === 0) {
              await client.sendMessage(senderId, `Cliente com n√∫mero ${clientNumber} n√£o encontrado no sistema.`);
              break;
            }
            
            // Verificar se j√° existe um atendimento em andamento para este cliente
            const existingTicket = await conn.query(
              "SELECT id, assigned_to FROM support_queue WHERE whatsapp_number = ? AND status = 'in_progress'",
              [clientNumber]
            );
            
            if (existingTicket.length > 0 && existingTicket[0].assigned_to !== attendantId) {
              // Cliente j√° est√° sendo atendido por outro atendente
              const otherAttendant = await conn.query(
                "SELECT name FROM attendants WHERE id = ?",
                [existingTicket[0].assigned_to]
              );
              
              const attendantName = otherAttendant.length > 0 ? otherAttendant[0].name : "outro atendente";
              await client.sendMessage(senderId, `Este cliente j√° est√° sendo atendido por ${attendantName}.`);
              break;
            }
            
            // Atualizar ou criar ticket de atendimento
            if (existingTicket.length > 0) {
              // J√° existe um ticket para este cliente com este atendente
              await client.sendMessage(senderId, `Voc√™ j√° est√° em atendimento com ${clientExists[0].name}. Continue a conversa normalmente.`);
            } else {
              // Criar novo ticket ou atualizar ticket existente na fila
              const waitingTicket = await conn.query(
                "SELECT id FROM support_queue WHERE whatsapp_number = ? AND status = 'waiting'",
                [clientNumber]
              );
              
              if (waitingTicket.length > 0) {
                // Atualizar ticket existente
                await conn.query(
                  "UPDATE support_queue SET status = 'in_progress', assigned_to = ? WHERE id = ?",
                  [attendantId, waitingTicket[0].id]
                );
              } else {
                // Criar novo ticket
                await conn.query(
                  "INSERT INTO support_queue (client_id, whatsapp_number, status, assigned_to) VALUES (?, ?, 'in_progress', ?)",
                  [clientExists[0].id, clientNumber, attendantId]
                );
              }
              
              // Atualizar status do atendente para ocupado
              await conn.query(
                "UPDATE attendants SET status = 'busy' WHERE id = ?",
                [attendantId]
              );
              
              // Notificar cliente
              await client.sendMessage(
                clientId,
                `Ol√°! Sou ${attendantName}, atendente da empresa, e estou aqui para ajud√°-lo. Como posso ser √∫til hoje?`
              );
              
              await client.sendMessage(
                senderId,
                `‚úÖ Atendimento iniciado com ${clientExists[0].name} (${clientNumber}).\nTodas as suas mensagens ser√£o encaminhadas para o cliente at√© que voc√™ use o comando /finalizar.`
              );
            }
            break;
            
          case '/enviarpix':
            if (!params) {
              await client.sendMessage(senderId, "Por favor, forne√ßa o n√∫mero do cliente. Exemplo: /enviarpix 5541999999999");
              break;
            }
            
            const pixClientNumber = params.trim();
            const pixClientId = `${pixClientNumber}@c.us`;
            
            // Buscar chave PIX no banco de dados
            const pixConfig = await conn.query("SELECT value FROM config WHERE name = 'pix_key'");
            
            if (pixConfig.length === 0 || !pixConfig[0].value) {
              await client.sendMessage(senderId, "Chave PIX n√£o configurada no sistema.");
              break;
            }
            
            const pixKey = pixConfig[0].value;
            
            // Enviar chave PIX para o cliente
            await client.sendMessage(
              pixClientId,
              `*Chave PIX para Pagamento*\n\nSegue nossa chave PIX para pagamento:\n\n${pixKey}\n\nAp√≥s realizar o pagamento, por favor envie o comprovante para confirmarmos.`
            );
            
            await client.sendMessage(
              senderId,
              `‚úÖ Chave PIX enviada com sucesso para o cliente ${pixClientNumber}.`
            );
            break;
            
          case '/enviarboleto':
            if (!params) {
              await client.sendMessage(senderId, "Por favor, forne√ßa o n√∫mero do cliente. Exemplo: /enviarboleto 5541999999999");
              break;
            }
            
            const boletoClientNumber = params.trim();
            const boletoClientId = `${boletoClientNumber}@c.us`;
            
            // Verificar se o cliente existe
            const boletoClient = await conn.query(
              "SELECT id, name FROM clients WHERE whatsapp_number = ?",
              [boletoClientNumber]
            );
            
            if (boletoClient.length === 0) {
              await client.sendMessage(senderId, `Cliente com n√∫mero ${boletoClientNumber} n√£o encontrado no sistema.`);
              break;
            }
            
            // Buscar boletos do cliente
            const boletos = await conn.query(
              "SELECT id, reference, due_date, amount, pdf_url FROM boletos WHERE client_id = ? ORDER BY due_date DESC",
              [boletoClient[0].id]
            );
            
            if (boletos.length === 0) {
              await client.sendMessage(senderId, `N√£o foram encontrados boletos para o cliente ${boletoClient[0].name}.`);
              break;
            }
            
            // Enviar o boleto mais recente
            const latestBoleto = boletos[0];
            const dueDate = new Date(latestBoleto.due_date).toLocaleDateString('pt-BR');
            
            await client.sendMessage(
              boletoClientId,
              `*Segunda via de boleto*\n\nSegue a segunda via do seu boleto:\n\nRefer√™ncia: ${latestBoleto.reference}\nVencimento: ${dueDate}\nValor: R$ ${latestBoleto.amount.toFixed(2)}\n\nO boleto ser√° enviado em seguida.`
            );
            
            // Enviar PDF do boleto
            if (latestBoleto.pdf_url) {
              try {
                const media = await MessageMedia.fromUrl(latestBoleto.pdf_url);
                await client.sendMessage(boletoClientId, media, {
                  caption: `Boleto - Vencimento: ${dueDate}`
                });
                
                await client.sendMessage(
                  senderId,
                  `‚úÖ Boleto enviado com sucesso para o cliente ${boletoClient[0].name}.`
                );
              } catch (error) {
                console.error("[ERRO] Falha ao enviar PDF do boleto:", error);
                await client.sendMessage(
                  senderId,
                  `‚ùå Erro ao enviar PDF do boleto. URL inv√°lida ou inacess√≠vel: ${latestBoleto.pdf_url}`
                );
              }
            } else {
              await client.sendMessage(
                senderId,
                `‚ö†Ô∏è O boleto n√£o possui URL do PDF cadastrada no sistema.`
              );
            }
            break;
            
          default:
            await client.sendMessage(
              senderId,
              "Comando de atendente n√£o reconhecido. Use /finalizar, /falarcom [numero], /enviarpix [numero] ou /enviarboleto [numero]."
            );
        }
        conn.release();
        return; // Sai do fluxo normal, pois √© um comando de atendente
      }
      
      // Se n√£o for atendente, verificar se √© t√©cnico
      const technicianModule = require('./technician_module.js');
      const isTechnicianCommand = await technicianModule.processTechnicianCommand(client, conn, senderId, senderNumber, command, params);
      if (isTechnicianCommand) {
        conn.release();
        return; // Sai do fluxo normal, pois √© um comando de t√©cnico
      }
      
    } catch (error) {
      console.error('[ERRO DB] Erro ao processar comando de atendente/t√©cnico:', error);
      await client.sendMessage(senderId, "Ocorreu um erro ao processar seu comando. Tente novamente mais tarde.");
      if (conn) conn.release();
      return;
    } finally {
      if (conn) conn.release();
    }
  }

  // Processar bot√µes de t√©cnico
  if (msg.selectedButtonId) {
    let conn = await pool.getConnection();
    try {
      const technicianModule = require('./technician_module.js');
      const isTechnicianButton = await technicianModule.processTechnicianButton(client, conn, senderId, senderNumber, msg, userState);
      if (isTechnicianButton) {
        conn.release();
        return; // Sai do fluxo normal, pois √© um bot√£o de t√©cnico
      }
    } catch (error) {
      console.error('[ERRO DB] Erro ao processar bot√£o de t√©cnico:', error);
      await client.sendMessage(senderId, "Ocorreu um erro ao processar sua a√ß√£o. Tente novamente mais tarde.");
      if (conn) conn.release();
      return;
    } finally {
      if (conn) conn.release();
    }
  }

  // Processar estados de t√©cnico
  const stateInfo = userState[senderId];
  if (stateInfo && stateInfo.state && stateInfo.state.startsWith('awaiting_technician')) { // Exemplo de prefixo para estados de t√©cnico
    let conn = await pool.getConnection();
    try {
      const technicianModule = require('./technician_module.js');
      const isTechnicianState = await technicianModule.processTechnicianState(client, conn, senderId, senderNumber, msg, stateInfo);
      if (isTechnicianState) {
        conn.release();
        return; // Sai do fluxo normal, pois √© um estado de t√©cnico
      }
    } catch (error) {
      console.error('[ERRO DB] Erro ao processar estado de t√©cnico:', error);
      await client.sendMessage(senderId, "Ocorreu um erro ao processar sua solicita√ß√£o. Tente novamente mais tarde.");
      if (conn) conn.release();
      return;
    } finally {
      if (conn) conn.release();
    }
  }

  // --- L√≥gica de Cliente Normal ---
  let conn = await pool.getConnection();
  let currentClient = null;
  try {
    const clientResult = await conn.query(
      "SELECT id, name, address, last_interaction_type FROM clients WHERE whatsapp_number = ? LIMIT 1",
      [senderNumber]
    );
    if (clientResult.length > 0) {
      currentClient = clientResult[0];
      console.log(`[DB] Cliente encontrado: ${currentClient.name}`);
    } else {
      console.log("[DB] Cliente n√£o encontrado, iniciando cadastro.");
    }
  } catch (dbError) {
    console.error("[ERRO DB] Falha ao buscar cliente:", dbError);
    await client.sendMessage(
      senderId,
      "Desculpe, estou com problemas para acessar nosso sistema no momento. Por favor, tente novamente em alguns instantes."
    );
    if (conn) conn.release();
    return;
  }

  if (!userState[senderId]) {
    if (!currentClient) {
      userState[senderId] = { state: "awaiting_name", data: {} };
      console.log(`[ESTADO] Novo estado: awaiting_name para ${senderId}`);
      await client.sendMessage(
        senderId,
        "Ol√°! Sou o assistente virtual da Kadan Tech. Para come√ßarmos, qual √© o seu nome?"
      );
    } else {
      // Cliente j√° cadastrado, verificar √∫ltima intera√ß√£o
      if (currentClient.last_interaction_type && currentClient.last_interaction_type !== "Avalia√ß√£o") {
        userState[senderId] = {
          state: "awaiting_repeat_or_menu",
          data: { lastInteraction: currentClient.last_interaction_type },
        };
        console.log(`[ESTADO] Novo estado: awaiting_repeat_or_menu para ${senderId}`);
        await client.sendMessage(
          senderId,
          `Ol√° ${currentClient.name}, bem-vindo(a) de volta! Sua √∫ltima intera√ß√£o foi sobre: *${currentClient.last_interaction_type}*.\n\n1. Repetir esta a√ß√£o\n2. Ver menu principal`
        );
      } else {
        await showMainMenu(senderId, currentClient.name);
      }
    }
  } else {
    // Processar estado atual do cliente
    const stateInfo = userState[senderId];
    console.log(`[ESTADO] Processando estado ${stateInfo.state} para ${senderId}`);

    switch (stateInfo.state) {
      case "awaiting_name":
        const name = msg.body.trim();
        if (name.length < 2) {
          await client.sendMessage(senderId, "Por favor, digite um nome v√°lido.");
          break;
        }
        stateInfo.data.name = name;
        stateInfo.state = "awaiting_address";
        console.log(`[DADO] Nome recebido: ${name}`);
        console.log(`[ESTADO] Estado atualizado para awaiting_address para ${senderId}`);
        await client.sendMessage(
          senderId,
          `Obrigado, ${name}! Agora, por favor, me informe seu endere√ßo completo (Rua, N√∫mero, Bairro, Cidade).`
        );
        break;

      case "awaiting_address":
        const address = msg.body.trim();
        if (address.length < 5) {
          await client.sendMessage(senderId, "Por favor, digite um endere√ßo v√°lido.");
          break;
        }
        stateInfo.data.address = address;
        console.log(`[DADO] Endere√ßo recebido: ${address}`);
        try {
          const insertResult = await conn.query(
            "INSERT INTO clients (name, whatsapp_number, address) VALUES (?, ?, ?) ON DUPLICATE KEY UPDATE name = VALUES(name), address = VALUES(address)",
            [stateInfo.data.name, senderNumber, stateInfo.data.address]
          );
          currentClient = { id: insertResult.insertId, name: stateInfo.data.name, address: stateInfo.data.address }; // Atualiza currentClient
          console.log(
            `[DB] Cliente ${stateInfo.data.name} (ID: ${insertResult.insertId}) salvo/atualizado com sucesso.`
          );
          await showMainMenu(senderId, stateInfo.data.name);
        } catch (dbError) {
          console.error("[ERRO DB] Falha ao salvar cliente:", dbError);
          await client.sendMessage(
            senderId,
            "Desculpe, n√£o consegui salvar seus dados agora. Tente novamente mais tarde."
          );
          delete userState[senderId];
        }
        break;

      case "awaiting_menu_choice":
        const choice = msg.body.trim();
        let nextState = null;
        let responseMessage = "";
        let interactionType = ""; // Para salvar no ticket

        switch (choice) {
          case "1": // Financeiro
            interactionType = "Financeiro";
            nextState = "awaiting_finance_choice";
            responseMessage =
              "Voc√™ escolheu Financeiro. O que voc√™ gostaria de fazer?\n\n1. Consultar Chave PIX\n2. Consultar Boletos Pendentes";
            break;
          case "2": // Agendamento
            interactionType = "Agendamento";
            nextState = "awaiting_specialty";
            // TODO: Buscar especialidades do banco ou de uma config
            const specialtiesList = ["Manuten√ß√£o Preventiva", "Reparo Urgente", "Instala√ß√£o", "Outro"];
            let specialtyMenu = "Voc√™ escolheu Agendamento. Qual servi√ßo voc√™ precisa?\n\n";
            specialtiesList.forEach((spec, index) => {
                specialtyMenu += `${index + 1}. ${spec}\n`;
            });
            responseMessage = specialtyMenu;
            break;
          case "3": // D√∫vidas / Falar com Atendente
            interactionType = "Suporte Atendente";
            // L√≥gica de fila de atendimento
            try {
                // Verificar se j√° existe um ticket aberto para este cliente
                const existingTicket = await conn.query(
                    "SELECT id, status FROM support_queue WHERE client_id = ? AND status IN ('waiting', 'in_progress')", 
                    [currentClient.id]
                );

                if (existingTicket.length > 0) {
                    if (existingTicket[0].status === 'waiting') {
                        const queuePosition = await conn.query(
                            "SELECT COUNT(*) as position FROM support_queue WHERE status = 'waiting' AND created_at <= (SELECT created_at FROM support_queue WHERE id = ?)",
                            [existingTicket[0].id]
                        );
                        responseMessage = `Voc√™ j√° est√° na fila de atendimento. Sua posi√ß√£o atual √©: ${queuePosition[0].position}. Por favor, aguarde.`;
                    } else {
                        responseMessage = "Voc√™ j√° est√° sendo atendido. Por favor, aguarde a resposta do atendente.";
                    }
                } else {
                    // Inserir cliente na fila
                    await conn.query(
                        "INSERT INTO support_queue (client_id, whatsapp_number, status) VALUES (?, ?, 'waiting')",
                        [currentClient.id, senderNumber]
                    );
                    
                    // Notificar atendentes dispon√≠veis
                    const availableAttendants = await conn.query(
                        "SELECT whatsapp_number FROM attendants WHERE status = 'available'"
                    );
                    
                    if (availableAttendants.length > 0) {
                        for (const attendant of availableAttendants) {
                            const attendantId = `${attendant.whatsapp_number}@c.us`;
                            await client.sendMessage(attendantId, `üîî Novo cliente na fila de atendimento: ${currentClient.name} (${senderNumber}). Use /falarcom ${senderNumber} para atender.`);
                        }
                        responseMessage = "Voc√™ escolheu D√∫vidas / Falar com Atendente. Voc√™ foi adicionado √† fila e um atendente ir√° contat√°-lo em breve.";
                    } else {
                        responseMessage = "Voc√™ escolheu D√∫vidas / Falar com Atendente. No momento, todos os nossos atendentes est√£o ocupados. Por favor, aguarde e voc√™ ser√° atendido assim que poss√≠vel.";
                    }
                }
            } catch (dbError) {
              console.error("[ERRO DB] Falha ao processar fila de atendimento:", dbError);
              responseMessage = "Voc√™ escolheu D√∫vidas / Falar com Atendente. Ocorreu um erro ao processar seu pedido. Por favor, tente novamente mais tarde.";
            }
            
            await client.sendMessage(senderId, responseMessage);
            return; // Sai do fluxo normal
          case "4": // Info Servi√ßos
            interactionType = "Info Servi√ßos";
            responseMessage = "Voc√™ escolheu Informa√ß√µes sobre Servi√ßos. Nossos principais servi√ßos s√£o: Manuten√ß√£o Preventiva, Reparos Urgentes e Instala√ß√µes. Para mais detalhes, por favor, selecione a op√ß√£o de agendamento ou fale com um atendente.";
            // Apenas informa, n√£o muda estado, finaliza intera√ß√£o
            await client.sendMessage(senderId, responseMessage);
            await showThankYouAndRating(senderId, currentClient ? currentClient.id : null, interactionType);
            return; // Sai do fluxo normal
          case "5": // Cancelar Agendamento
            interactionType = "Cancelamento";
            nextState = "awaiting_cancel_confirmation";
            // Buscar agendamentos ativos do cliente
            try {
              const activeAppointments = await conn.query(
                "SELECT a.id, a.specialty, a.scheduled_datetime, a.period, a.google_calendar_event_id FROM appointments a WHERE a.client_id = ? AND a.status = 'scheduled' AND a.scheduled_datetime > NOW() ORDER BY a.scheduled_datetime ASC",
                [currentClient.id]
              );
              
              if (activeAppointments.length === 0) {
                await client.sendMessage(senderId, "Voc√™ n√£o possui agendamentos ativos para cancelar.");
                await showMainMenu(senderId, currentClient.name);
                return;
              }
              
              // Armazenar os agendamentos no estado para uso posterior
              stateInfo.data.activeAppointments = activeAppointments;
              
              // Mostrar lista de agendamentos para cancelar
              let appointmentList = "Agendamentos ativos:\n\n";
              activeAppointments.forEach((apt, index) => {
                const aptDate = new Date(apt.scheduled_datetime);
                appointmentList += `${index + 1}. ${apt.specialty} - ${aptDate.toLocaleDateString('pt-BR')} (${apt.period})\n`;
              });
              appointmentList += "\nDigite o n√∫mero do agendamento que deseja cancelar:";
              
              responseMessage = appointmentList;
            } catch (dbError) {
              console.error("[ERRO DB] Falha ao buscar agendamentos ativos:", dbError);
              await client.sendMessage(senderId, "Desculpe, n√£o consegui verificar seus agendamentos agora. Tente novamente mais tarde.");
              await showMainMenu(senderId, currentClient.name);
              return;
            }
            break;
          case "admin": // Comando administrativo para lembretes
            // Verificar se o n√∫mero √© de um administrador
            try {
              const isAdmin = await conn.query(
                "SELECT 1 FROM admin_users WHERE whatsapp_number = ?",
                [senderNumber]
              );
              
              if (isAdmin.length === 0) {
                await client.sendMessage(senderId, "Voc√™ n√£o tem permiss√£o para acessar comandos administrativos.");
                await showMainMenu(senderId, currentClient.name);
                return;
              }
              
              // Mostrar menu administrativo
              const adminMenu = 
                "üîß *Menu Administrativo*\n\n" +
                "1. Enviar lembretes para agendamentos de amanh√£\n" +
                "2. Voltar ao menu principal\n\n" +
                "Digite o n√∫mero da op√ß√£o desejada:";
              
              stateInfo.state = "awaiting_admin_choice";
              await client.sendMessage(senderId, adminMenu);
              return;
            } catch (dbError) {
              console.error("[ERRO DB] Falha ao verificar permiss√µes de administrador:", dbError);
              await client.sendMessage(senderId, "Desculpe, ocorreu um erro ao processar seu comando. Tente novamente mais tarde.");
              await showMainMenu(senderId, currentClient.name);
              return;
            }
            break;
            
          default:
            await client.sendMessage(
              senderId,
              "Op√ß√£o inv√°lida. Por favor, digite o n√∫mero de uma das op√ß√µes do menu."
            );
            await showMainMenu(senderId, currentClient ? currentClient.name : "Cliente");
            return;
        }

        // Save interaction type to a new ticket
        if (interactionType && currentClient && currentClient.id) {
           try {
              await conn.query(
                  "INSERT INTO tickets (client_id, last_interaction_type, status) VALUES (?, ?, ?)",
                  [currentClient.id, interactionType, "open"]
              );
              console.log(`[DB] Novo ticket criado para cliente ${currentClient.id} com intera√ß√£o ${interactionType}`);
           } catch (ticketError) {
              console.error("[ERRO DB] Erro ao criar ticket: ", ticketError);
           }
        }

        // Update state and send next message
        if (nextState) {
          userState[senderId] = { ...stateInfo, state: nextState };
          console.log(`[ESTADO] Estado atualizado para ${nextState} para ${senderId}`);
          await client.sendMessage(senderId, responseMessage);
        } else {
          // Should not happen for valid choices handled above, but as fallback:
          console.warn(`[AVISO] nextState n√£o definido para escolha ${choice}, finalizando fluxo.`);
          await showThankYouAndRating(senderId, currentClient ? currentClient.id : null, interactionType);
        }
        break;

      case "awaiting_finance_choice":
          const financeChoice = msg.body.trim();
          console.log(`[DADO] Op√ß√£o Financeiro: ${financeChoice}`);
          if (financeChoice === "1") { // Consultar PIX
              let pixKey = "Chave PIX n√£o configurada.";
              try {
                  const settingResult = await conn.query("SELECT setting_value FROM settings WHERE setting_key = ?", ["pix_key"]);
                  if (settingResult.length > 0) pixKey = settingResult[0].setting_value;
              } catch (e) { console.error("[ERRO DB] Erro ao buscar chave PIX", e); }
              await client.sendMessage(senderId, `Nossa chave PIX √©: ${pixKey}`);
              await showThankYouAndRating(senderId, currentClient?.id, "Consulta PIX");
          } else if (financeChoice === "2") { // Consultar Boleto
              try {
                  const invoices = await conn.query("SELECT id, description, due_date, amount, pdf_url FROM invoices WHERE client_id = ? AND status = ? ORDER BY due_date ASC", [currentClient.id, "pending"]);
                  if (invoices.length === 0) {
                      await client.sendMessage(senderId, "Voc√™ n√£o possui boletos pendentes no momento.");
                      await showThankYouAndRating(senderId, currentClient?.id, "Consulta Boleto (Nenhum)");
                  } else {
                      let invoiceList = "Boletos pendentes:\n";
                      invoices.forEach((inv, index) => {
                          invoiceList += `\n${index + 1}. ${inv.description} (Venc: ${new Date(inv.due_date).toLocaleDateString("pt-BR")}, R$ ${inv.amount.toFixed(2)})`;
                      });
                      invoiceList += "\n\nDigite o n√∫mero do boleto que deseja receber:";
                      userState[senderId] = { ...stateInfo, state: "awaiting_invoice_choice", data: { ...stateInfo.data, invoices: invoices } };
                      console.log(`[ESTADO] Estado atualizado para awaiting_invoice_choice para ${senderId}`);
                      await client.sendMessage(senderId, invoiceList);
                  }
              } catch (dbErr) {
                  console.error("[ERRO DB] Erro ao buscar boletos:", dbErr);
                  await client.sendMessage(senderId, "Desculpe, n√£o consegui consultar seus boletos agora. Tente novamente mais tarde.");
                  delete userState[senderId];
              }
          } else {
              await client.sendMessage(senderId, "Op√ß√£o inv√°lida. Por favor, digite 1 para PIX ou 2 para Boletos.");
          }
          break;

      case "awaiting_invoice_choice":
          const invoiceIndex = parseInt(msg.body.trim()) - 1;
          const userInvoices = stateInfo.data.invoices;
          if (userInvoices && invoiceIndex >= 0 && invoiceIndex < userInvoices.length) {
              const selectedInvoice = userInvoices[invoiceIndex];
              console.log(`[DADO] Boleto selecionado: ID ${selectedInvoice.id}`);
              if (selectedInvoice.pdf_url) {
                  try {
                      const media = await MessageMedia.fromUrl(selectedInvoice.pdf_url, { unsafeMime: true }); // unsafeMime pode ser necess√°rio dependendo da URL
                      await client.sendMessage(senderId, `Aqui est√° o boleto para ${selectedInvoice.description}:`, { media: media });
                      console.log(`[INFO] PDF do boleto ${selectedInvoice.id} enviado para ${senderId}`);
                      await showThankYouAndRating(senderId, currentClient?.id, "Envio Boleto PDF");
                  } catch (mediaError) {
                      console.error(`[ERRO M√çDIA] Falha ao buscar/enviar PDF do boleto ${selectedInvoice.id} da URL ${selectedInvoice.pdf_url}:`, mediaError);
                      await client.sendMessage(senderId, `Desculpe, n√£o consegui obter o PDF do boleto (${selectedInvoice.description}) no momento. Por favor, entre em contato com o suporte.`);
                      await showThankYouAndRating(senderId, currentClient?.id, "Envio Boleto PDF (Erro)");
                  }
              } else {
                  await client.sendMessage(senderId, `O boleto selecionado (${selectedInvoice.description}) n√£o possui um arquivo PDF dispon√≠vel para envio autom√°tico. Por favor, entre em contato com o suporte.`);
                  console.log(`[INFO] Boleto ${selectedInvoice.id} sem PDF para ${senderId}`);
                  await showThankYouAndRating(senderId, currentClient?.id, "Envio Boleto (Sem PDF)");
              }
          } else {
              await client.sendMessage(senderId, "N√∫mero de boleto inv√°lido. Por favor, digite o n√∫mero correspondente ao boleto desejado da lista anterior.");
          }
          break;

      case "awaiting_repeat_or_menu":
          const repeatChoice = msg.body.trim();
          console.log(`[DADO] Resposta para repetir/menu: ${repeatChoice}`);
          if (repeatChoice === "1") {
              // TODO: Implementar l√≥gica para repetir a √∫ltima a√ß√£o
              await client.sendMessage(senderId, `Ok, vamos repetir a a√ß√£o: \"${stateInfo.data.lastInteraction}\". (Funcionalidade ainda em desenvolvimento)`);
              delete userState[senderId];
              console.log(`[ESTADO] Estado removido para ${senderId} ap√≥s escolher repetir.`);
          } else if (repeatChoice === "2") {
              await showMainMenu(senderId, currentClient ? currentClient.name : "Cliente");
          } else {
              await client.sendMessage(senderId, "Op√ß√£o inv√°lida. Por favor, digite 1 para repetir ou 2 para ver o menu.");
          }
          break;

      // --- Novos Estados para Agendamento ---
      case "awaiting_specialty":
          const specialtyChoiceIndex = parseInt(msg.body.trim()) - 1;
          // TODO: Usar a mesma lista de especialidades definida anteriormente
          const specialtiesList = ["Manuten√ß√£o Preventiva", "Reparo Urgente", "Instala√ß√£o", "Outro"];
          if (specialtyChoiceIndex >= 0 && specialtyChoiceIndex < specialtiesList.length) {
              const chosenSpecialty = specialtiesList[specialtyChoiceIndex];
              stateInfo.data.specialty = chosenSpecialty;
              stateInfo.state = "awaiting_problem_description";
              console.log(`[DADO] Especialidade escolhida: ${chosenSpecialty}`);
              console.log(`[ESTADO] Estado atualizado para awaiting_problem_description para ${senderId}`);
              await client.sendMessage(senderId, `Entendido: ${chosenSpecialty}.\n\nAgora, por favor, descreva o problema ou o servi√ßo que voc√™ precisa. Se poss√≠vel, envie fotos para ajudar no diagn√≥stico.`);
          } else {
              await client.sendMessage(senderId, "Op√ß√£o de especialidade inv√°lida. Por favor, digite o n√∫mero correspondente.");
          }
          break;

      case "awaiting_problem_description":
          // L√≥gica aprimorada para lidar com texto E/OU m√≠dia (fotos)
          if (msg.type === "chat") {
              const messageText = msg.body.trim().toLowerCase();
              
              // Verifica se √© um comando para finalizar o envio de fotos
              if (messageText === "pronto" || messageText === "finalizar" || messageText === "concluir") {
                  if (stateInfo.data.attachments && stateInfo.data.attachments.length > 0) {
                      // Se j√° enviou fotos e agora est√° finalizando
                      if (!stateInfo.data.problemDescription) {
                          // Se ainda n√£o tem descri√ß√£o, pede para descrever o problema
                          await client.sendMessage(senderId, "Entendi que voc√™ terminou de enviar fotos. Agora, por favor, descreva o problema ou servi√ßo que voc√™ precisa em texto.");
                          return;
                      } else {
                          // Se j√° tem descri√ß√£o e fotos, avan√ßa para verificar disponibilidade
                          stateInfo.state = "fetching_availability";
                          console.log(`[ESTADO] Estado atualizado para fetching_availability para ${senderId} ap√≥s finalizar fotos`);
                          await client.sendMessage(senderId, `Obrigado pelas ${stateInfo.data.attachments.length} foto(s) e pela descri√ß√£o. Vou verificar os hor√°rios dispon√≠veis na agenda. Isso pode levar um momento...`);
                          await fetchAndShowAvailability(senderId, stateInfo.data);
                          return;
                      }
                  } else {
                      // Tentou finalizar sem enviar fotos
                      await client.sendMessage(senderId, "Voc√™ ainda n√£o enviou nenhuma foto. Por favor, envie fotos do problema ou descreva o problema em texto.");
                      return;
                  }
              }
              
              // Caso seja uma descri√ß√£o normal em texto
              stateInfo.data.problemDescription = messageText;
              console.log(`[DADO] Descri√ß√£o do problema recebida: ${stateInfo.data.problemDescription}`);
              
              // Se j√° tem fotos, pergunta se quer enviar mais ou avan√ßar
              if (stateInfo.data.attachments && stateInfo.data.attachments.length > 0) {
                  await client.sendMessage(senderId, 
                      `Descri√ß√£o recebida! Voc√™ j√° enviou ${stateInfo.data.attachments.length} foto(s).\n\n` +
                      `Voc√™ pode:\n` +
                      `1. Enviar mais fotos\n` +
                      `2. Digite "pronto" para avan√ßar para a sele√ß√£o de hor√°rios`
                  );
                  return;
              } else {
                  // Se n√£o tem fotos, pergunta se quer enviar fotos
                  stateInfo.state = "awaiting_photos_confirmation";
                  console.log(`[ESTADO] Estado atualizado para awaiting_photos_confirmation para ${senderId}`);
                  await client.sendMessage(senderId, 
                      `Descri√ß√£o recebida: "${stateInfo.data.problemDescription}".\n\n` +
                      `Voc√™ gostaria de enviar fotos para ajudar no diagn√≥stico?\n` +
                      `1. Sim, enviar fotos\n` +
                      `2. N√£o, seguir para hor√°rios`
                  );
              }
          } else if (msg.type === "image" || msg.type === "video") {
              // Lidar com o recebimento de m√≠dia
              try {
                  const media = await msg.downloadMedia();
                  if (!media || !media.data) {
                      await client.sendMessage(senderId, "N√£o foi poss√≠vel processar esta m√≠dia. Tente novamente.");
                      return;
                  }

                  // Salvar m√≠dia em um diret√≥rio tempor√°rio ou processar diretamente
                  const uploadDir = path.join(__dirname, 'uploads');
                  if (!fs.existsSync(uploadDir)) {
                      fs.mkdirSync(uploadDir, { recursive: true });
                  }
                  const timestamp = new Date().getTime();
                  const fileName = `${senderNumber}_${timestamp}.${media.mimetype.split('/')[1]}`;
                  const filePath = path.join(uploadDir, fileName);
                  
                  // Salvar arquivo
                  const fileData = media.data.replace(/^data:image\/\w+;base64,/, ''); // Remove prefixo se houver
                  fs.writeFileSync(filePath, Buffer.from(fileData, 'base64'));
                  console.log(`[M√çDIA] M√≠dia salva em: ${filePath}`);

                  // Adicionar caminho do arquivo ao estado do usu√°rio
                  if (!stateInfo.data.attachments) {
                      stateInfo.data.attachments = [];
                  }
                  stateInfo.data.attachments.push(filePath);
                  
                  const photoCount = stateInfo.data.attachments.length;
                  await client.sendMessage(senderId, 
                      `Foto #${photoCount} recebida!\n\n` +
                      `Voc√™ pode enviar mais fotos ou, se j√° terminou, digite "pronto".\n` +
                      `Se ainda n√£o descreveu o problema, por favor, fa√ßa-o em texto.`
                  );

              } catch (error) {
                  console.error("[ERRO M√çDIA] Falha ao processar m√≠dia:", error);
                  await client.sendMessage(senderId, "Ocorreu um erro ao processar a m√≠dia. Tente novamente.");
              }
          } else {
              await client.sendMessage(senderId, "Por favor, envie uma descri√ß√£o em texto ou uma foto/v√≠deo do problema.");
          }
          break;

      case "awaiting_photos_confirmation":
          const photoConfirm = msg.body.trim();
          if (photoConfirm === "1" || photoConfirm.toLowerCase() === "sim") {
              stateInfo.state = "awaiting_problem_description"; // Volta para permitir envio de fotos
              console.log(`[ESTADO] Estado atualizado para awaiting_problem_description (para fotos) para ${senderId}`);
              await client.sendMessage(senderId, "Ok, pode enviar as fotos. Quando terminar, digite 
